var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/// <reference path="references.ts" />
var StringManager = (function () {
    function StringManager() {
        this.container = new createjs.Container();
        this.strings = new Object();
        this.allStrings = null;
        this.allStrings = g_strings;
        this.setLanguage("en");
    }
    StringManager.getInstance = function () {
        return StringManager.g_instance;
    };
    StringManager.prototype.getString = function (string_id) {
        if (!this.strings) {
            return "!!!";
        }
        return this.strings[string_id] || "???";
    };
    StringManager.prototype.setLanguage = function (lang) {
        this.strings = this.allStrings[lang];
        this.language = lang;
    };
    StringManager.prototype.getLanguagePrefix = function () {
        if (this.language == "en") {
            return "";
        }
        return this.language + "/";
    };
    StringManager.prototype.getLanguage = function () {
        return this.language;
    };
    return StringManager;
}());
StringManager.g_instance = new StringManager();
StringManager.REMOVE = "REMOVE";
StringManager.CLEAR = "CLEAR";
StringManager.EARN = "EARN";
StringManager.PAUSE = "PAUSE";
StringManager.ACHIEVEMENT = "ACHIEVEMENT";
StringManager.TUTORIAL_1 = "TUTORIAL_1";
StringManager.TUTORIAL_2 = "TUTORIAL_2";
StringManager.TUTORIAL_3 = "TUTORIAL_3";
StringManager.TUTORIAL_4 = "TUTORIAL_4";
StringManager.TUTORIAL_5 = "TUTORIAL_5";
StringManager.TOTAL_SCORE = "TOTAL_SCORE";
StringManager.NEW_TREASURE = "NEW_TREASURE";
StringManager.POINTS = "POINTS";
StringManager.GJ_MESSAGE = "GJ_MESSAGE";
/// <reference path="references.ts" />
var SoundManager = (function () {
    function SoundManager() {
        this.soundEnabled = true;
        this.initiliazed = false;
        this.focus = true;
        this.hidden = false;
        this.wasSoundEnabled = true;
        this.wasPauseCall = false;
        //  dirty hack
        this.wasMusicPlay = false;
    }
    SoundManager.prototype.onLostFocus = function () {
        this.focus = false;
        this.calcSoundEnabled(this.soundEnabled);
    };
    SoundManager.prototype.onFocus = function () {
        this.focus = true;
        this.calcSoundEnabled(this.soundEnabled);
    };
    SoundManager.prototype.init = function () {
        try {
            if (!this.initiliazed) {
                if (!createjs.Sound.initializeDefaultPlugins()) {
                    return;
                }
                this.initiliazed = true;
            }
        }
        catch (e) {
        }
    };
    SoundManager.prototype.isSoundEnabled = function () {
        return this.soundEnabled;
    };
    SoundManager.prototype.calcSoundEnabled = function (enabled) {
        this.soundEnabled = enabled;
        var is_mute = !enabled || !this.focus;
        //try
        //{
        //    if (is_mute)
        //    {
        //        if (this.musicInstance)
        //        {
        //            this.musicInstance.stop();
        //            this.musicInstance = null;
        //        }
        //    }
        //    else
        //    {
        //        this.playMusic();
        //    }
        //}
        //catch (e)
        //{
        //}
        try {
            if (createjs.Sound.getMute() == is_mute) {
                return;
            }
            createjs.Sound.setMute(is_mute);
            if (is_mute) {
                if (this.musicInstance) {
                    this.musicInstance.stop();
                    this.musicInstance = null;
                }
            }
            else {
                this.playMusic();
            }
        }
        catch (e) {
        }
    };
    SoundManager.prototype.play = function (name, volume) {
        try {
            if (!volume) {
                volume = 1;
            }
            if (this.initiliazed && this.soundEnabled) {
                return createjs.Sound.play(name, createjs.Sound.INTERRUPT_NONE, 0, 0, 0, volume);
            }
        }
        catch (e) {
        }
        return null;
    };
    SoundManager.prototype.playMusic = function () {
        try {
            if (this.initiliazed && this.soundEnabled) {
                if (this.musicInstance) {
                    this.musicInstance.stop();
                    this.musicInstance = null;
                }
                //if (!this.wasMusicPlay)
                {
                    //this.wasMusicPlay = true;
                    this.musicInstance = createjs.Sound.play(SoundManager.SOUND_MUSIC, createjs.Sound.INTERRUPT_NONE, 0, 0, -1, 0.2);
                    if (this.musicInstance.playState == "playFailed") {
                        //this.wasMusicPlay = false;
                        return null;
                    }
                }
            }
        }
        catch (e) {
        }
        return null;
    };
    SoundManager.prototype.playMusicFirstTime = function () {
        if (!this.wasMusicPlay) {
            this.wasMusicPlay = true;
            this.playMusic();
        }
    };
    SoundManager.prototype.update = function () {
        //this.soundsOnFrame.length = 0;
        //if (this.initiliazed)
        //{
        //    if (document.hidden || document["webkitHidden"] || document.visibilityState == "hidden" || document["msHidden"])
        //    {
        //        this.hidden = true;
        //    }
        //    else
        //    {
        //        this.hidden = false;
        //    }
        //    this.setSoundEnabled(this.soundEnabled);
        //}
    };
    SoundManager.prototype.onPause = function () {
        this.wasPauseCall = true;
        this.wasSoundEnabled = this.isSoundEnabled();
        if (this.isSoundEnabled()) {
            this.calcSoundEnabled(false);
        }
    };
    SoundManager.prototype.onResume = function () {
        if (this.wasPauseCall) {
            if (this.wasSoundEnabled) {
                this.calcSoundEnabled(true);
            }
            this.wasPauseCall = false;
        }
    };
    return SoundManager;
}());
SoundManager.g_instance = new SoundManager();
SoundManager.SOUND_MUSIC = "music";
SoundManager.SOUND_CLICK = "click";
SoundManager.SOUND_MATCH_1 = "match_1";
SoundManager.SOUND_MATCH_2 = "match_2";
SoundManager.SOUND_MATCH_3 = "match_3";
SoundManager.SOUND_MATCH_4 = "match_4";
SoundManager.SOUND_MATCH_5 = "match_5";
SoundManager.SOUND_DROP_1 = "drop_1";
SoundManager.SOUND_DROP_2 = "drop_2";
SoundManager.SOUND_DROP_3 = "drop_3";
SoundManager.SOUND_LINE = "line";
SoundManager.SOUND_KILL_COLOR = "kill_color";
SoundManager.SOUND_LOSE = "lose";
SoundManager.SOUND_BOOM = "boom";
SoundManager.SOUND_AWESOME = "awesome";
SoundManager.SOUND_EXCHANGE = "exchange";
SoundManager.SOUND_WIN = "win";
SoundManager.SOUND_SHAMAN = "shaman";
SoundManager.SOUND_VERTICAL_LIGHTING = "vertical_lighting";
/// <reference path="references.ts" />
var StateManager = (function () {
    function StateManager(manifest, sound_manifest, athlases, localizable_images) {
        var _this = this;
        this.statesConstainer = new createjs.Container();
        this.mouseDown = false;
        this.timeDevider = 1;
        this.liveTime = 0;
        this.adsCD = firstAd;
        this.isLoading = true;
        this.lastTime = 0;
        this.lastMouseUpHandlerTime = -1;
        this.lastMouseDownHandlerTime = -1;
        this.lastMouseMoveHandlerTime = -1;
        StateManager.g_instance = this;
        this.states = Array();
        //  create stage and point it to the canvas:
        this.canvas = document.getElementById("canvas");
        //  check to see if we are running in a browser with touch support
        this.stage = new createjs.Stage(this.canvas);
        this.stage.autoClear = false;
        var badAndroidDevice = navigator.userAgent.indexOf("Android") > -1 && !(navigator.userAgent.indexOf("Chrome") > -1);
        if (badAndroidDevice && createjs.Touch.isSupported()) {
            this.stage.enableDOMEvents(false);
        }
        //  enable touch interactions if supported on the current device:
        createjs.Touch.enable(this.stage);
        createjs.MotionGuidePlugin.install();
        //  enabled mouse over / out events
        this.stage.enableMouseOver(5);
        createjs.Ticker.timingMode = createjs.Ticker.RAF;
        createjs.Ticker.setFPS(60);
        createjs.Ticker.addEventListener("tick", function (e) { return _this.update(e); });
        if (Constants.DEBUG_MODE) {
            document.onkeydown = function (e) { return _this.onKeyDown(e); };
        }
        this.pushState(new PreloaderState(manifest, sound_manifest, athlases, localizable_images));
        this.stage.addChild(this.statesConstainer);
        Constants.PIXEL_RATIO = (window.devicePixelRatio ? window.devicePixelRatio : 1);
        if (Constants.g_isPC) {
            window.onresize = (function (e) { return _this.onResize(e); });
            this.onResize(null);
        }
        else {
            if (viewporter.ACTIVE) {
                window.addEventListener('viewportready', function () { return _this.onOrientationChanged(); });
                window.addEventListener('viewportchange', function () { return _this.onOrientationChanged(); });
            }
            else {
                window.addEventListener("orientationchange", function () { return _this.onOrientationChanged(); });
            }
            this.onOrientationChanged();
        }
        this.stage.addEventListener(Constants.MOUSE_MOVE, (function (e) { return _this.handleMouse(e); }));
        this.stage.addEventListener(Constants.MOUSE_DOWN, (function (e) { return _this.handleMouse(e); }));
        this.stage.addEventListener(Constants.MOUSE_UP, (function (e) { return _this.handleMouse(e); }));
        if (Visibility.isSupported()) {
            Visibility.change(function (e, state) {
                console.log(state);
                if (state == "hidden") {
                    StateManager.g_instance.onLostFocus(null);
                }
                else if (state == "visible") {
                    StateManager.g_instance.onFocus(null);
                }
            });
        }
    }
    StateManager.prototype.isLandscape = function () {
        return viewporter.isLandscape();
    };
    StateManager.prototype.onOrientationChanged = function () {
        this.resizeTo(window.innerWidth, window.innerHeight);
    };
    StateManager.prototype.onResize = function (e) {
        this.resizeTo(window.innerWidth, window.innerHeight);
    };
    //  Jelly Madness style
    StateManager.prototype.resizeTo = function (w, h) {
        //  if portrait
        if (w < h) {
            Constants.SCREEN_SCALE = w / Constants.ASSETS_WIDTH * Constants.PIXEL_RATIO;
        }
        else {
            Constants.SCREEN_SCALE = Math.min(w / Constants.ASSETS_WIDTH, h / Constants.ASSETS_HEIGHT) * Constants.PIXEL_RATIO;
        }
        //  canvas h = screen h anyway
        Constants.SCREEN_HEIGHT = h / Constants.SCREEN_SCALE * Constants.PIXEL_RATIO;
        this.canvas.width = Constants.ASSETS_WIDTH * Constants.SCREEN_SCALE;
        this.canvas.height = h * Constants.PIXEL_RATIO;
        this.canvas.style.width = this.canvas.width / Constants.PIXEL_RATIO + "px";
        this.canvas.style.height = this.canvas.height / Constants.PIXEL_RATIO + "px";
        this.statesConstainer.scaleX = this.statesConstainer.scaleY = Constants.SCREEN_SCALE;
        this.canvas.style.marginLeft = (w - Constants.ASSETS_WIDTH * Constants.SCREEN_SCALE / Constants.PIXEL_RATIO) / 2 + "px";
        this.canvas.style.marginTop = "0px";
    };
    StateManager.prototype.allAssetsLoaded = function () {
        var _this = this;
        this.isLoading = false;
        if (window.onpagehide) {
            window.onpagehide = (function (e) { return _this.onLostFocus(e); });
        }
        if (window.onblur) {
            window.onblur = (function (e) { return _this.onLostFocus(e); });
        }
        if (window.onpageshow) {
            window.onpageshow = (function (e) { return _this.onFocus(e); });
        }
        if (window.onfocus) {
            window.onfocus = (function (e) { return _this.onFocus(e); });
        }
        GameData.getInstance().load();
        this.changeState(new MainMenuState());
    };
    StateManager.prototype.restartAdsCD = function () {
        this.adsCD = adFreq;
    };
    StateManager.prototype.update = function (event) {
        var tm = createjs.Ticker.getTime();
        var delta = (tm - this.lastTime);
        this.lastTime = tm;
        if (delta > 500) {
            delta = 500;
        }
        var dt = delta * 0.001 / this.timeDevider;
        this.liveTime += dt;
        if (this.adsCD > 0) {
            this.adsCD -= dt;
        }
        SoundManager.g_instance.update();
        if (this.states.length != 0) {
            var top_state = this.states[this.states.length - 1];
            if (!top_state.isInitiliazed()) {
                top_state.init();
            }
            top_state.update(dt);
        }
        //
        for (var i = 0; i < this.states.length; i++) {
            this.states[i].alignByCenter(false);
        }
        for (var i = 0; i < this.states.length; i++) {
            this.states[i].forceUpdate(dt);
        }
        this.stage.update(event);
    };
    StateManager.prototype.changeState = function (game_state) {
        while (this.states.length != 0) {
            this.popState();
        }
        this.pushState(game_state);
    };
    StateManager.prototype.pushState = function (game_state) {
        this.states.push(game_state);
        this.statesConstainer.addChild(game_state);
    };
    StateManager.prototype.popState = function () {
        if (this.states.length != 0) {
            this.states[this.states.length - 1].cleanup();
            this.statesConstainer.removeChild(this.states[this.states.length - 1]);
            this.states.pop();
            if (this.states.length != 0) {
                this.states[this.states.length - 1].resume();
            }
        }
    };
    StateManager.prototype.onLostFocus = function (e) {
        SoundManager.g_instance.onLostFocus();
    };
    StateManager.prototype.onFocus = function (e) {
        SoundManager.g_instance.onFocus();
    };
    StateManager.prototype.handleMouse = function (event) {
        if (this.states.length == 0) {
            return;
        }
        event.preventDefault();
        var top_state = this.states[this.states.length - 1];
        switch (event.type) {
            case Constants.MOUSE_DOWN:
                {
                    SoundManager.g_instance.init();
                    if (!this.isLoading) {
                        SoundManager.g_instance.playMusicFirstTime();
                    }
                    if (this.liveTime == this.lastMouseDownHandlerTime) {
                        return;
                    }
                    this.lastMouseDownHandlerTime = this.liveTime;
                    this.mouseDown = true;
                    top_state.onMouseDown(event.stageX / Constants.SCREEN_SCALE, event.stageY / Constants.SCREEN_SCALE);
                }
                break;
            case Constants.MOUSE_UP:
                {
                    if (this.liveTime == this.lastMouseUpHandlerTime) {
                        return;
                    }
                    this.lastMouseUpHandlerTime = this.liveTime;
                    this.mouseDown = false;
                    top_state.onMouseUp(event.stageX / Constants.SCREEN_SCALE, event.stageY / Constants.SCREEN_SCALE);
                }
                break;
            case Constants.MOUSE_MOVE:
                {
                    if (this.liveTime == this.lastMouseMoveHandlerTime) {
                        return;
                    }
                    this.lastMouseMoveHandlerTime = this.liveTime;
                    if (this.mouseDown) {
                        top_state.onMouseMove(event.stageX / Constants.SCREEN_SCALE, event.stageY / Constants.SCREEN_SCALE);
                    }
                }
                break;
        }
    };
    StateManager.prototype.onKeyDown = function (event) {
        switch (event.keyCode) {
            //  key a
            case 65:
                {
                    this.timeDevider = 5;
                }
                break;
            case 66:
                {
                    this.timeDevider = 0.2;
                }
                break;
            case 68:
                {
                    this.timeDevider = 10;
                }
                break;
        }
        this.stage.update();
    };
    StateManager.prototype.onPause = function () {
        if (this.states.length != 0) {
            this.states[this.states.length - 1].onPause();
        }
    };
    StateManager.prototype.onResume = function () {
        if (this.states.length != 0) {
            this.states[this.states.length - 1].onResume();
        }
    };
    StateManager.prototype.onRestart = function () {
        if (this.states.length != 0) {
            this.states[this.states.length - 1].onRestart();
        }
    };
    StateManager.prototype.isMouseDownNow = function () {
        return this.mouseDown;
    };
    return StateManager;
}());
/// <reference path="references.ts" />
var GameState = (function (_super) {
    __extends(GameState, _super);
    function GameState() {
        var _this = _super.call(this) || this;
        _this.liveTime = 0.0;
        _this.gameObjects = new Array();
        _this.gui = new Array();
        _this.newGameObjects = new Array();
        _this.initiliazed = false;
        _this.consoleH = 200;
        _this.haveFill = false;
        return _this;
    }
    GameState.prototype.getShader = function () {
        return this.shaderShape;
    };
    GameState.prototype.addShader = function (color) {
        //  shading
        this.shaderShape = new createjs.Shape();
        this.shaderShape.graphics.beginFill("#14dffe");
        this.shaderShape.graphics.drawRect(0, 0, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT);
        this.shaderShape.graphics.endFill();
        this.addChild(this.shaderShape);
        this.shaderShape.y = -(Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        this.shaderShape.alpha = 0;
        createjs.Tween.get(this.shaderShape).wait(300).to({ alpha: 0.75 }, 800, createjs.Ease.linear);
    };
    GameState.prototype.consolePrint = function (text) {
        var label = new createjs.Text(text, "bold 35px Arial", "#000000");
        this.addChild(label);
        label.x = 50;
        label.y = this.consoleH;
        this.consoleH += 40;
    };
    GameState.prototype.isInitiliazed = function () {
        return this.initiliazed;
    };
    GameState.prototype.onMouseDown = function (x, y) {
        GUIObject.wasHandlerThisFrame = false;
        for (var i = 0; i < this.gui.length; i++) {
            this.gui[i].onMouseDown(x, y);
        }
    };
    GameState.prototype.onMouseMove = function (x, y) {
        for (var i = 0; i < this.gui.length; i++) {
            this.gui[i].onMouseMove(x, y);
        }
    };
    GameState.prototype.onMouseUp = function (x, y) {
        GUIObject.wasHandlerThisFrame = false;
        for (var i = 0; i < this.gui.length; i++) {
            this.gui[i].onMouseUp(x, y);
        }
    };
    GameState.prototype.addGuiObject = function (gui_object) {
        this.gui.push(gui_object);
        this.addGameObject(gui_object);
    };
    GameState.prototype.update = function (dt) {
        this.liveTime += dt;
        this.newGameObjects = new Array();
        for (var i = 0; i < this.gameObjects.length; i++) {
            var obj = this.gameObjects[i];
            obj.update(dt);
            if (obj.isDead()) {
                obj.onDead();
            }
            else {
                this.newGameObjects.push(obj);
            }
        }
        this.gameObjects = this.newGameObjects;
    };
    GameState.prototype.forceUpdate = function (dt) {
        for (var i = 0; i < this.gameObjects.length; i++) {
            this.gameObjects[i].forceUpdate(dt);
        }
    };
    GameState.prototype.addGameObject = function (obj) {
        this.gameObjects.push(obj);
    };
    GameState.prototype.addGameObjectAt = function (obj, layer) {
        this.gameObjects.push(obj);
        if (layer) {
            layer.addChild(obj);
        }
    };
    GameState.prototype.addGameObjectAtPos = function (obj, layer, x, y) {
        this.gameObjects.push(obj);
        if (layer) {
            layer.addChild(obj);
            obj.x = x;
            obj.y = y;
        }
    };
    GameState.prototype.addGameObjectAtPosWithDelay = function (obj, layer, x, y, delay) {
        obj.x = x;
        obj.y = y;
        this.addGameObject(new GameObjectAdder(obj, delay, this, layer));
    };
    GameState.prototype.cleanup = function () {
    };
    GameState.prototype.resume = function () {
    };
    GameState.prototype.init = function () {
        this.initiliazed = true;
    };
    GameState.prototype.onOrientationChanged = function (landscape) {
        if (landscape) {
            //StateManager.g_instance.pushState(new PortraitLockState())
        }
    };
    GameState.prototype.alignByCenter = function (need_add_fill) {
        if (!Constants.g_isPC) {
            this.y = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        }
        else {
            return;
        }
        if (Constants.ASSETS_HEIGHT < Constants.SCREEN_HEIGHT && !this.haveFill && need_add_fill) {
            this.haveFill = true;
            var fill_down = AssetsManager.g_instance.getImage("fill");
            this.addChild(fill_down);
            var fill_up = AssetsManager.g_instance.getImage("fill");
            this.addChild(fill_up);
            var fill_h = 200;
            var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
            if (diff > fill_h) {
                fill_down.scaleY = (diff / fill_h);
                fill_up.scaleY = (diff / fill_h);
                fill_down.y = Constants.ASSETS_HEIGHT;
                fill_up.y = -fill_h * fill_up.scaleY;
            }
            else {
                fill_down.y = Constants.ASSETS_HEIGHT;
                fill_up.y = -fill_h;
            }
        }
    };
    GameState.prototype.loadLayout = function (layout, layer) {
        for (var i = 0; i < layout.length; i++) {
            var element = layout[i];
            var gui_object = this.loadGUIObject(element, layer);
            if (element["children"]) {
                this.loadLayout(element["children"], gui_object);
            }
        }
    };
    GameState.prototype.loadGUIObject = function (element, layer) {
        var x = element["x"];
        var y = element["y"];
        var name = element["name"];
        var picture = element["picture"];
        var gui_object;
        if (gui_object) {
            gui_object.name = name;
            gui_object.x = x;
            gui_object.y = y;
            this.addGuiObject(gui_object);
            layer.addChild(gui_object);
            gui_object.scaleX = gui_object.scaleY = (element["scale"] || 1);
        }
        else {
            console.log("Parsing layout error. Cant find type: ", element["type"]);
        }
        return gui_object;
    };
    GameState.prototype.findGUIObject = function (name) {
        for (var i = 0; i < this.gui.length; i++) {
            if (this.gui[i].name == name) {
                return this.gui[i];
            }
        }
        return null;
    };
    GameState.prototype.onPause = function () {
    };
    GameState.prototype.onResume = function () {
    };
    GameState.prototype.onRestart = function () {
    };
    return GameState;
}(createjs.Container));
/// <reference path="references.ts" />
var Constants = (function () {
    function Constants() {
    }
    return Constants;
}());
Constants.GRADIENT_TRANSITION_TIME = 0.2;
Constants.g_DEBUG = false;
Constants.LOAD_COMPLETE = "LOAD_COMPLETE";
//  Messages... Why lib does not contain them???
Constants.MOUSE_DOWN = "stagemousedown";
Constants.MOUSE_UP = "stagemouseup";
Constants.MOUSE_MOVE = "stagemousemove"; //   hz
Constants.CELL_SIZE = 85;
Constants.FIELD_OFFSET_X = 51;
Constants.FIELD_OFFSET_Y = 189;
//  gameplay const
Constants.EXCHANGE_TIME = 0.220;
Constants.MATCH_TIME = 0.25;
Constants.GRAVITY_ACC = 2500; // pixels per second
Constants.ASSETS_WIDTH = 700;
Constants.ASSETS_HEIGHT = 900;
Constants.PIXEL_RATIO = 1;
Constants.SCREEN_HEIGHT = 900;
Constants.SCREEN_WIDTH = 700;
Constants.SCREEN_SCALE = 1;
Constants.DPI = -1;
Constants.g_isPC = true;
Constants.DEBUG_MODE = true;
Constants.COLOR_PINK = "#ffE5E5";
Constants.COLOR_BLUE = "#619CC4";
Constants.IMAGE_BUTTON_CLOSE = "button_close";
Constants.IMAGE_BUTTON_SOUND_ON = "button_sound_on";
Constants.IMAGE_BUTTON_SOUND_OFF = "button_sound_off";
Constants.IMAGE_BUTTON_EXIT = "button_exit";
Constants.IMAGE_BUTTON_PAUSE = "button_pause";
Constants.IMAGE_BUTTON_RESTART = "button_restart";
Constants.IMAGE_BUTTON_CREDITS = "button_credits";
Constants.IMAGE_BUTTON_PLAY = "button_play";
Constants.IMAGE_SHINING = "shining";
Constants.IMAGE_DROP = "drop";
Constants.IMAGE_BACK = "back";
Constants.IMAGE_BONUS_COLOR = "donut";
Constants.IMAGE_BONUS_SHAMAN = "shaman_bonus";
Constants.IMAGE_BONUS_CROSS = "cross_bonus";
Constants.IMAGE_BONUS_CROSS_P1 = "cross_bonus_p1";
Constants.IMAGE_BONUS_CROSS_ARROW = "cross_bonus_p2";
Constants.IMAGE_BONUS_BOMB = "bomb_bonus";
Constants.IMAGE_BONUS_CROSS_GUI = "cross_bonus_gui";
Constants.IMAGE_MESSAGE_WINDOW = "message_window";
Constants.IMAGE_HINT_ARROW = "hint_arrow";
Constants.IMAGE_GAMEOVER_CAPTION = "gameover_caption";
Constants.IMAGE_TITLE_MAIN_MENU_BACK = "main_menu_back";
Constants.IMAGE_TITLE = "title";
Constants.IMAGE_SICKLE = "sickle";
Constants.IMAGE_ROTATE = "rotate";
Constants.IMAGE_LEVEL_BUTTON = "level_button";
Constants.IMAGE_LEVEL_BUTTON_DOWN = "level_button_down";
Constants.IMAGE_LEVEL_BUTTON_FLAG = "level_button_flag";
Constants.IMAGE_DIRT = "dirt";
Constants.IMAGE_GUI = "gui";
Constants.IMAGE_LOCK = "lock";
Constants.IMAGE_OUT_OF_MOVES = "out_of_moves";
Constants.IMAGE_WIN_CAPTION = "win_caption";
Constants.IMAGE_STONE_HEART = "stone_heart";
Constants.IMAGE_TASK_PANEL = "task_panel";
Constants.IMAGE_HEART_PARTICLE = "heart_particle";
Constants.IMAGE_SELECT_LEVEL_BACK = "select_level_back";
Constants.IMAGE_BUSH_1 = "bush_1";
Constants.IMAGE_BUSH_2 = "bush_2";
Constants.IMAGE_BUTTON_ACHIEVEMENTS = "button_achievements";
Constants.IMAGE_ACHIEVEMENTS_BACK = "achievements_back";
Constants.IMAGE_FIRST_LEVEL_HINT = "first_level_hint";
Constants.IMAGE_FLASH = "flash";
Constants.IMAGE_GRADIENT = "gradient";
Constants.IMAGE_BLACK_SQUARE = "black_square";
Constants.IMAGE_WIN_CAPTION_EYES = "win_caption_eyes";
Constants.IMAGE_EYES_OPENED = "eyes_opened";
Constants.IMAGE_EYES_FLASH = "eyes_flash";
Constants.IMAGE_CAGE = "cage";
/// <reference path="references.ts" />
//class AssetsManager extends createjs.Container
var AssetsManager = (function () {
    function AssetsManager(manifest, sound_manifest, athlases, localizable_images, progress_callback) {
        this.imageNameToSpriteSheetName = new Object();
        AssetsManager.g_instance = this;
        this.athlases = athlases;
        this.localizableImages = localizable_images;
        this.manifest = manifest;
        this.soundManifest = sound_manifest;
        this.progressCallBack = progress_callback;
        this.startDownLoad();
    }
    AssetsManager.prototype.startDownLoad = function () {
        var _this = this;
        this.loader = new createjs.LoadQueue();
        this.loader.addEventListener("progress", function (e) { return _this.progressCallBack(e); });
        this.loader.addEventListener("complete", function (e) { return _this.handleComplete(e); });
        createjs.Sound.registerManifest(this.soundManifest, "assets/sound/");
        this.loader.installPlugin(createjs.SoundJS);
        this.loader.loadManifest(this.manifest);
    };
    AssetsManager.prototype.handleComplete = function (event) {
        try {
            //  handle athlases
            for (var i = 0; i < this.athlases.length; i++) {
                var obj = this.athlases[i];
                obj["images"] = [this.getBitmap(obj["images"][0]).image];
                var sprite_sheet = new createjs.SpriteSheet(obj);
                var animation_names = sprite_sheet.getAnimations();
                for (var nm = 0; nm < animation_names.length; nm++) {
                    this.imageNameToSpriteSheetName[animation_names[nm]] = sprite_sheet;
                }
            }
        }
        catch (e) {
            console.log(e);
        }
        StateManager.g_instance.allAssetsLoaded();
    };
    AssetsManager.prototype.getResult = function (name) {
        return this.loader.getResult(name);
    };
    AssetsManager.prototype.getBitmap = function (name) {
        var bitmap = new createjs.Bitmap(this.loader.getResult(name));
        if (!bitmap.getBounds()) {
            console.log("bitmap error", name);
        }
        return bitmap;
    };
    AssetsManager.prototype.getCenteredBitmap = function (name) {
        var bitmap = new createjs.Bitmap(this.loader.getResult(name));
        if (!bitmap.image) {
            console.log("ERROR HERE", name);
        }
        bitmap.x = -bitmap.image.width / 2;
        bitmap.y = -bitmap.image.height / 2;
        return bitmap;
    };
    //public getImage(name: string): createjs.DisplayObject
    AssetsManager.prototype.getImage = function (name) {
        if (this.localizableImages.indexOf(name) != -1) {
            name = StringManager.getInstance().getLanguagePrefix() + name;
        }
        var proxy = new createjs.Container();
        if (this.imageNameToSpriteSheetName[name]) {
            //return this.getSprite(name);
            proxy.addChild(this.getSprite(name));
            return proxy;
        }
        //return this.getBitmap(name);
        proxy.addChild(this.getBitmap(name));
        return proxy;
    };
    AssetsManager.prototype.getCenteredImage = function (name) {
        var image = this.getImage(name);
        image.x = -image.getBounds().width / 2;
        image.y = -image.getBounds().height / 2;
        return image;
    };
    AssetsManager.prototype.getCenteredImageWithProxy = function (name) {
        var proxy = new createjs.Container();
        proxy.addChild(this.getCenteredImage(name));
        return proxy;
    };
    AssetsManager.prototype.getSprite = function (name) {
        var sprite = new createjs.Sprite(this.imageNameToSpriteSheetName[name], name);
        sprite.stop();
        return sprite;
    };
    AssetsManager.prototype.getCenteredSprite = function (name) {
        var sprite = this.getSprite(name);
        sprite.x = -sprite.getBounds().width / 2;
        sprite.y = -sprite.getBounds().height / 2;
        return sprite;
    };
    return AssetsManager;
}());
/// <reference path="references.ts" />
var GameObject = (function (_super) {
    __extends(GameObject, _super);
    function GameObject() {
        var _this = _super.call(this) || this;
        _this.liveTime = 0;
        _this.forceLiveTime = 0;
        _this.killed = false;
        return _this;
    }
    GameObject.prototype.update = function (dt) {
        this.liveTime += dt;
    };
    GameObject.prototype.forceUpdate = function (dt) {
        this.forceLiveTime += dt;
    };
    GameObject.prototype.kill = function () {
        this.killed = true;
    };
    GameObject.prototype.isDead = function () {
        return this.killed;
    };
    GameObject.prototype.onDead = function () {
        //  cleanup here
        if (this.parent) {
            this.parent.removeChild(this);
        }
    };
    return GameObject;
}(createjs.Container));
/// <reference path="references.ts" />
var Chip = (function (_super) {
    __extends(Chip, _super);
    function Chip(id, x_index, y_index, spawn_x_pos, spawn_y_pos, spawn_delay) {
        var _this = _super.call(this) || this;
        _this.STATE_NORMAL = "STATE_NORMAL";
        _this.STATE_EXCHANGE = "STATE_EXCHANGE";
        _this.STATE_SHIFT_DOWN = "STATE_SHIFT_DOWN";
        _this.wasClear = false;
        _this.state = null;
        _this.rotationSpeed = 0;
        _this.selected = false;
        _this.stateTime = 0;
        _this.rotationTimeOffset = Utils.RandomRange(0, 20);
        _this.bonusType = null;
        _this.doubleMatched = false;
        _this.canBeMatched = true;
        _this.matchReason = null;
        _this.cage = null;
        _this.tween = new createjs.Tween(_this);
        _this.isLeft = false;
        _this.reboundOffset = 0;
        _this.reboundSpeed = 0;
        _this.reboundCounter = 0;
        _this.rebounding = false;
        _this.isHorizCross = false;
        _this.hole = false;
        _this.stoneHeart = false;
        //  hz
        _this.obtacle = false;
        _this.obtaclePower = 2;
        _this.spawnYPos = spawn_y_pos;
        _this.spawnXPos = spawn_x_pos;
        _this.setIncexes(x_index, y_index);
        if (id != 9 && id != 0 && id != 8) {
            _this.chipPicture = AssetsManager.g_instance.getCenteredImageWithProxy("cake_" + id);
            _this.addChild(_this.chipPicture);
        }
        _this.colorID = id;
        _this.setState(Chip.STATE_SPAWN_NEW);
        _this.spawnDelay = spawn_delay;
        if (id == 8) {
            _this.convertToObtacle(2);
        }
        if (id == 9) {
            _this.convertToStoneHeart();
        }
        return _this;
    }
    Chip.prototype.getMatchReason = function () {
        return this.matchReason;
    };
    Chip.prototype.setCage = function () {
        this.cage = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_CAGE);
        this.addChild(this.cage);
    };
    Chip.prototype.haveCage = function () {
        return this.cage != null;
    };
    Chip.prototype.getBonusType = function () {
        return this.bonusType;
    };
    Chip.prototype.getColorID = function () {
        return this.colorID;
    };
    Chip.prototype.getIndeces = function () {
        return new createjs.Point(this.indexX, this.indexY);
    };
    Chip.prototype.getIndexX = function () {
        return this.indexX;
    };
    Chip.prototype.getIndexY = function () {
        return this.indexY;
    };
    Chip.prototype.setIncexes = function (x, y) {
        this.indexX = x;
        this.indexY = y;
    };
    Chip.prototype.isMatching = function () {
        return this.state == Chip.STATE_MATCH;
    };
    Chip.prototype.land = function () {
        if (!this.haveCage()) {
            this.reboundOffset = 0;
            //reboundSpeed : number = 0;
            this.reboundCounter = 0;
            this.rebounding = true;
        }
    };
    Chip.prototype.update = function (dt) {
        this.stateTime += dt;
        switch (this.state) {
            case this.STATE_NORMAL:
                {
                    //  ???
                    if (this.stoneHeart) {
                        break;
                    }
                    if (this.rebounding) {
                        this.reboundSpeed += Constants.GRAVITY_ACC * dt;
                        this.reboundOffset += this.reboundSpeed * dt;
                        if (this.reboundOffset >= 0) {
                            this.reboundOffset = -1;
                            //this.reboundSpeed = -this.reboundSpeed;
                            switch (this.reboundCounter) {
                                case 0:
                                    this.reboundSpeed = -170;
                                    break;
                                //case 1:
                                //    this.reboundSpeed = -70;
                                //    break;
                                //case 2:
                                //    this.reboundSpeed = -70;
                                //    break;
                                default:
                                    this.reboundOffset = 0;
                                    this.rebounding = false;
                                    this.reboundSpeed = 0;
                                    break;
                            }
                            this.reboundCounter++;
                        }
                        this.chipPicture.y = this.reboundOffset;
                    }
                    this.canBeMatched = true;
                }
                break;
            case this.STATE_EXCHANGE:
                {
                    if (this.stateTime >= Constants.EXCHANGE_TIME) {
                        this.setState(this.STATE_NORMAL);
                    }
                }
                break;
            case Chip.STATE_SPAWN_NEW:
                {
                    this.spawnDelay -= dt;
                    if (this.spawnDelay < 0) {
                        this.updateKinematic(dt);
                        this.x = this.spawnXPos;
                        if (this.y >= this.spawnYPos) {
                            this.y = this.spawnYPos;
                            this.setState(this.STATE_NORMAL);
                            if (!this.haveCage()) {
                                PlayState.g_instance.onShiftEnded();
                            }
                            this.land();
                        }
                    }
                }
                break;
            case this.STATE_SHIFT_DOWN:
                {
                    //this.speed.y += this.acceleration.y * dt;
                    //this.x += dt * this.speed.x;
                    //this.y += dt * this.speed.y;
                    if (this.y >= this.spawnYPos) {
                        if (this.x == this.spawnXPos) {
                            this.y = this.spawnYPos;
                            this.setState(this.STATE_NORMAL);
                            PlayState.g_instance.onShiftEnded();
                            this.land();
                        }
                    }
                    //  restore form
                }
                break;
            case Chip.STATE_FALL_DOWN:
                {
                    this.speed.y += this.acceleration.y * dt;
                    this.x += dt * this.speed.x;
                    this.y += dt * this.speed.y;
                    this.rotation += this.rotationSpeed * dt;
                    if (this.y >= 1000) {
                        this.kill();
                    }
                }
                break;
            case Chip.STATE_MATCH_BY_LIGHTING:
                {
                    if (this.stateTime >= Constants.MATCH_TIME && !this.wasClear) {
                        //this.fallDown();
                        this.fallDownStrong();
                        //  ???
                        //PlayState.g_instance.setInpunState(PlayState.g_instance.INPUT_STATE_MATCHING);
                    }
                }
                break;
            case Chip.STATE_MATCH:
                {
                    this.scaleY = 1.0 - this.stateTime * 1.3;
                    this.scaleX = 1.0 - this.stateTime * 1.3;
                    this.alpha = 1.0 - this.stateTime / Constants.MATCH_TIME;
                    if (this.stateTime >= Constants.MATCH_TIME / 2 && !this.wasClear) {
                        PlayState.g_instance.addPointsAt(this, this.matchReason);
                        PlayState.g_instance.clearCell(this);
                        this.wasClear = true;
                    }
                    if (this.stateTime >= Constants.MATCH_TIME) {
                        this.kill();
                    }
                }
                break;
        }
        if (this.shiningCircle) {
            this.shiningCircle.rotation += dt * 20;
        }
    };
    Chip.prototype.updateKinematic = function (dt) {
        if (this.state == this.STATE_SHIFT_DOWN && this.isLeft == true) {
            this.speed.x -= this.acceleration.x * dt;
        }
        else if (this.state == this.STATE_SHIFT_DOWN && this.isLeft == false) {
            this.speed.x += this.acceleration.x * dt;
        }
        this.speed.y += this.acceleration.y * dt;
        this.x += dt * this.speed.x;
        this.y += dt * this.speed.y;
        this.rotation += this.rotationSpeed * dt;
    };
    Chip.prototype.shiftDownChip = function (new_index_x, new_x, new_index_y, new_y) {
        this.speed = new createjs.Point(0, 0);
        this.deselect();
        this.indexX = new_index_x;
        this.indexY = new_index_y;
        this.spawnXPos = new_x;
        this.spawnYPos = new_y;
        this.tween.to({ x: this.spawnXPos, y: this.spawnYPos }, Math.sqrt((this.spawnXPos - this.x) * (this.spawnXPos - this.x) + (this.spawnYPos - this.y) * (this.spawnYPos - this.y)) * 1.5, createjs.Ease.linear);
        createjs.Tween.get(this).play(this.tween);
        this.setState(this.STATE_SHIFT_DOWN);
    };
    Chip.prototype.setState = function (state) {
        if (state == this.state) {
            return;
        }
        this.stateTime = 0;
        this.state = state;
        switch (state) {
            case this.STATE_NORMAL:
                break;
            case this.STATE_EXCHANGE:
                break;
            case this.STATE_SHIFT_DOWN:
                //  restore form
                createjs.Tween.get(this, { loop: false }).to({ scaleX: 1.0, scaleY: 1.0 }, 170, createjs.Ease.linear);
                break;
            case Chip.STATE_SPAWN_NEW:
                {
                    this.speed = new createjs.Point(0, 500);
                    this.acceleration = new createjs.Point(0, Constants.GRAVITY_ACC);
                }
                break;
        }
    };
    Chip.prototype.exchange = function (new_index_x, new_index_y) {
        this.deselect();
        this.setState(this.STATE_EXCHANGE);
        this.indexX = new_index_x;
        this.indexY = new_index_y;
    };
    Chip.prototype.shiftDown = function (new_index_y, new_y) {
        this.speed = new createjs.Point(0, -250);
        this.deselect();
        this.indexY = new_index_y;
        this.spawnYPos = new_y;
        this.setState(this.STATE_SHIFT_DOWN);
    };
    Chip.prototype.match = function (reason) {
        var _this = this;
        if (this.stoneHeart) {
            PlayState.g_instance.addGameObjectAtPos(new FallingTrash("stone_part_1"), PlayState.g_instance, this.x, this.y);
            PlayState.g_instance.addGameObjectAtPos(new FallingTrash("stone_part_1"), PlayState.g_instance, this.x, this.y);
            PlayState.g_instance.addGameObjectAtPos(new FallingTrash("stone_part_2"), PlayState.g_instance, this.x, this.y);
            var effect = new AutoreleaseEffect("stone_", 15, 0.035);
            effect.scaleX = effect.scaleY = 1.7;
            effect.rotation = 360 * Math.random();
            PlayState.g_instance.addGameObjectAtPos(effect, PlayState.g_instance.frontChipsLayer, this.x, this.y);
            PlayState.g_instance.clearCell(this);
            this.kill();
            return;
        }
        if (this.isHole()) {
            return;
        }
        if (this.isObtacle()) {
            this.damage();
            return;
        }
        if (this.state == Chip.STATE_MATCH) {
            this.doubleMatched = true;
        }
        if (!this.canBeMatched) {
            return;
        }
        this.matchReason = reason;
        if (this.haveCage()) {
            var effect = new AutoreleaseEffect("stone_", 15, 0.035);
            effect.scaleX = effect.scaleY = 1.7;
            effect.rotation = 360 * Math.random();
            PlayState.g_instance.addGameObjectAtPos(effect, PlayState.g_instance.frontChipsLayer, this.x, this.y);
            createjs.Tween.get(this.cage).to({ scaleX: 1.5, scaleY: 1.5, alpha: 0 }, 300, createjs.Ease.linear)
                .call(function () { _this.removeChild(_this.cage); });
            this.cage = null;
        }
        else {
            this.setState(Chip.STATE_MATCH);
            if (reason != Chip.MATCH_REASON_BONUS_EFFECT_5) {
                var explosion1 = new AutoreleaseEffect("match_effect_", 6, 0.04);
                explosion1.rotation = Math.random() * 360;
                PlayState.g_instance.addGameObjectAtPos(explosion1, PlayState.g_instance.frontChipsLayer, this.x, this.y);
            }
        }
    };
    Chip.prototype.matchByLighting = function () {
        this.setState(Chip.STATE_MATCH_BY_LIGHTING);
    };
    Chip.prototype.isDoubleMatched = function () {
        return this.doubleMatched;
    };
    Chip.prototype.select = function () {
        this.stateTime = 0;
        this.selected = true;
        this.scaleX = this.scaleY = 1.1;
    };
    Chip.prototype.deselect = function () {
        if (this.selected) {
            this.scaleX = this.scaleY = 1.0;
            this.selected = false;
        }
    };
    Chip.prototype.isNormal = function () {
        return this.state == this.STATE_NORMAL || this.state == Chip.STATE_HOLE;
    };
    Chip.prototype.getState = function () {
        return this.state;
    };
    Chip.prototype.isBonus = function () {
        return this.bonusType != null;
        ;
    };
    Chip.prototype.isChipHorizCross = function () {
        return this.isHorizCross;
    };
    Chip.prototype.dropFlags = function () {
        this.stoneHeart = false;
        this.hole = false;
        this.obtacle = false;
        this.cage = null;
    };
    Chip.prototype.convertToBonus = function (type, is_horiz_cross) {
        this.bonusType = type;
        this.dropFlags();
        this.removeAllChildren();
        switch (type) {
            case Chip.BONUS_COLOR:
                this.addChild(AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_BONUS_COLOR));
                break;
            case Chip.BONUS_CROSS:
                this.addChild(AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_BONUS_CROSS));
                this.addChild(AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_BONUS_CROSS_P1));
                this.isHorizCross = !is_horiz_cross;
                if (this.isHorizCross) {
                    var arrow_r = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_BONUS_CROSS_ARROW);
                    var arrow_l = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_BONUS_CROSS_ARROW);
                    arrow_r.rotation = 90;
                    arrow_r.x = 35;
                    arrow_l.rotation = -90;
                    arrow_l.x = -35;
                    this.addChild(arrow_r);
                    this.addChild(arrow_l);
                }
                else {
                    var arrow_t = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_BONUS_CROSS_ARROW);
                    var arrow_b = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_BONUS_CROSS_ARROW);
                    arrow_t.y = -35;
                    arrow_b.y = 35;
                    arrow_b.rotation = 180;
                    this.addChild(arrow_t);
                    this.addChild(arrow_b);
                }
                break;
            case Chip.BONUS_BOMB:
                this.addChild(AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_BONUS_BOMB));
                break;
            case Chip.BONUS_SHAMAN:
                this.addChild(AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_BONUS_SHAMAN));
                break;
        }
        if (this.state != Chip.STATE_SPAWN_NEW) {
            PlayState.g_instance.addConverToBonusEffect(this);
        }
        this.canBeMatched = false;
        this.colorID = -1;
        this.setState(this.STATE_NORMAL);
        //
        //PlayState.g_instance.tryClearDirt(this.indexX, this.indexY);
        //PlayState.g_instance.tryClearStoneHeart(this.indexX, this.indexY);
        //PlayState.g_instance.tryClearObtacles(this.indexX, this.indexY, Chip.MATCH_REASON_I_AM_BONUS);
    };
    Chip.prototype.fallDown = function () {
        if (this.state == Chip.STATE_FALL_DOWN) {
            return;
        }
        this.setState(Chip.STATE_FALL_DOWN);
        this.speed = new createjs.Point(Utils.RandomRange(-100, 100), -250);
        this.rotationSpeed = Utils.RandomRange(-300, 300);
        //  move front
        PlayState.g_instance.frontChipsLayer.addChild(this);
        if (!this.wasClear) {
            PlayState.g_instance.clearCell(this);
            this.wasClear = true;
        }
    };
    Chip.prototype.fallDownStrong = function () {
        if (this.state == Chip.STATE_FALL_DOWN) {
            return;
        }
        this.setState(Chip.STATE_FALL_DOWN);
        this.speed = new createjs.Point(Utils.RandomRange(-100, 100) * 2, -250 * 2);
        this.rotationSpeed = Utils.RandomRange(-450, 450);
        //  move front
        PlayState.g_instance.frontChipsLayer.addChild(this);
        if (!this.wasClear) {
            PlayState.g_instance.clearCell(this);
            this.wasClear = true;
        }
    };
    Chip.prototype.isHole = function () {
        return this.hole;
    };
    Chip.prototype.convertToHole = function () {
        this.removeAllChildren();
        this.hole = true;
        this.y = this.spawnYPos;
        this.setState(Chip.STATE_HOLE);
        this.colorID = -1;
        this.chipPicture = AssetsManager.g_instance.getCenteredImageWithProxy(Math.random() < 0.5 ? Constants.IMAGE_BUSH_1 : Constants.IMAGE_BUSH_2);
        this.addChild(this.chipPicture);
    };
    Chip.prototype.convertToStoneHeart = function () {
        this.stoneHeart = true;
        this.colorID = -1;
        this.chipPicture = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_STONE_HEART);
        this.addChild(this.chipPicture);
    };
    Chip.prototype.isStoneHeart = function () {
        return this.stoneHeart;
    };
    Chip.prototype.convertToObtacle = function (power) {
        this.obtacle = true;
        this.colorID = -1;
        this.y = this.spawnYPos;
        this.setState(Chip.STATE_HOLE);
        this.chipPicture = AssetsManager.g_instance.getCenteredImageWithProxy("obtacle_" + power);
        this.addChild(this.chipPicture);
    };
    Chip.prototype.isObtacle = function () {
        return this.obtacle;
    };
    Chip.prototype.damage = function () {
        this.obtaclePower--;
        if (this.obtaclePower <= 0) {
            PlayState.g_instance.addGameObjectAtPos(new FallingTrash("obtacle_part_1"), PlayState.g_instance, this.x + 5, this.y + 13);
            PlayState.g_instance.addGameObjectAtPos(new FallingTrash("obtacle_part_0"), PlayState.g_instance, this.x + 4, this.y - 18);
            PlayState.g_instance.addGameObjectAtPos(new FallingTrash("obtacle_part_2"), PlayState.g_instance, this.x - 17, this.y);
            PlayState.g_instance.clearCell(this);
            this.kill();
            //this.fallDown();
        }
        else {
            this.removeAllChildren();
            this.chipPicture = AssetsManager.g_instance.getCenteredImageWithProxy("obtacle_" + this.obtaclePower);
            this.addChild(this.chipPicture);
        }
        var effect = new AutoreleaseEffect("gold_", 17, 0.03);
        effect.scaleX = effect.scaleY = 1.3;
        PlayState.g_instance.addGameObjectAtPos(effect, PlayState.g_instance, this.x, this.y);
    };
    Chip.prototype.isChip = function () {
        return !this.hole && !this.stoneHeart && !this.isBonus() && !this.isObtacle();
    };
    Chip.prototype.movable = function () {
        return !this.hole && !this.haveCage() && !this.isObtacle();
    };
    return Chip;
}(GameObject));
Chip.BONUS_CROSS = "BONUS_CROSS";
Chip.BONUS_COLOR = "BONUS_COLOR";
Chip.BONUS_BOMB = "BONUS_BOMB";
Chip.BONUS_SHAMAN = "BONUS_SHAMAN";
Chip.STATE_SPAWN_NEW = "STATE_SPAWN_NEW";
Chip.STATE_MATCH = "STATE_MATCH";
Chip.STATE_FALL_DOWN = "STATE_FALL_DOWN";
Chip.STATE_MATCH_BY_LIGHTING = "STATE_MATCH_BY_LIGHTING";
Chip.STATE_HOLE = "STATE_HOLE";
Chip.MATCH_REASON_SIMPLE = "MATCH_REASON_SIMPLE";
Chip.MATCH_REASON_EXCHANGE_WIHT_BONUS = "MATCH_REASON_EXCHANGE_WIHT_BONUS";
Chip.MATCH_REASON_BONUS_EFFECT_5 = "MATCH_REASON_BONUS_EFFECT_5";
Chip.MATCH_REASON_BONUS_EFFECT_4_HOR = "MATCH_REASON_BONUS_EFFECT_4_HOR";
Chip.MATCH_REASON_BONUS_EFFECT_4_VERT = "MATCH_REASON_BONUS_EFFECT_4_VERT";
Chip.MATCH_REASON_I_AM_BONUS = "MATCH_REASON_I_AM_BONUS";
Chip.MATCH_REASON_NEAR = "MATCH_REASON_NEAR";
/// <reference path="references.ts" />
var Utils = (function () {
    function Utils() {
    }
    Utils.RandomRange = function (from, to) {
        return from + (to - from) * Math.random();
    };
    Utils.RandomRangeInt = function (from, to) {
        return Math.floor(Math.random() * (to - from + 1)) + from;
    };
    Utils.IntToTimeString = function (time) {
        var minutes = Math.floor(time / 60);
        var s_minutes = minutes.toString();
        var seconds = time % 60;
        var s_seconds;
        if (seconds < 10) {
            s_seconds = "0" + seconds;
        }
        else {
            s_seconds = seconds.toString();
        }
        return s_minutes + "d" + s_seconds;
    };
    Utils.RadToGrad = function (rad) {
        return rad * 180 / Math.PI;
    };
    Utils.GradToRad = function (grad) {
        return grad * Math.PI / 180;
    };
    Utils.IsMobileBrowser = function () {
        if (window["orientation"] != undefined) {
            return true;
        }
        var check = false;
        (function (a) { if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
            check = true; })(navigator.userAgent || navigator.vendor || window["opera"]);
        return check;
    };
    Utils.ScaledOffset = function (val) {
        return (window.devicePixelRatio ? window.devicePixelRatio : 1) * val / Constants.SCREEN_SCALE;
    };
    Utils.GetScoreString = function (score) {
        var str_score = score.toString();
        switch (str_score.length) {
            case 1:
                str_score = "00000" + str_score;
                break;
            case 2:
                str_score = "0000" + str_score;
                break;
            case 3:
                str_score = "000" + str_score;
                break;
            case 4:
                str_score = "00" + str_score;
                break;
            case 5:
                str_score = "0" + str_score;
                break;
        }
        return str_score;
    };
    return Utils;
}());
/// <reference path="references.ts" />
var AchievementsState = (function (_super) {
    __extends(AchievementsState, _super);
    function AchievementsState() {
        var _this = _super.call(this) || this;
        _this.positions = [
            544, 664,
            364, 241,
            207, 241,
            523, 241,
            363, 664,
            111, 459,
            273, 459,
            585, 459,
            174, 664,
            427, 459
        ];
        _this.fires = new Array();
        _this.fireSpeedAndAmp = new Array();
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        var back = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_ACHIEVEMENTS_BACK);
        back.x = Constants.ASSETS_WIDTH / 2;
        back.y = Constants.ASSETS_HEIGHT / 2;
        _this.addChild(back);
        var pause_panel = AssetsManager.g_instance.getCenteredImageWithProxy("pause_panel");
        pause_panel.y = -385;
        pause_panel.x = 20;
        back.addChild(pause_panel);
        var button_exit = new DNButton(Constants.IMAGE_BUTTON_EXIT, function () { return _this.onExitTouch(); });
        _this.addGuiObject(button_exit);
        _this.addChild(button_exit);
        button_exit.x = 70;
        button_exit.y = 70 - diff;
        var text_ach = new BitmapLabel(StringManager.getInstance().getString(StringManager.ACHIEVEMENT));
        text_ach.x = 20;
        text_ach.y = -420;
        back.addChild(text_ach);
        var hints = new Object();
        for (var i = 0; i < 10; i++) {
            if (GameData.getInstance().getAchievementsNum() > i) {
                var achiev_pic = AssetsManager.g_instance.getCenteredImageWithProxy("achievement_" + (i + 1));
                back.addChild(achiev_pic);
                achiev_pic.x = _this.positions[i * 2] - Constants.ASSETS_WIDTH / 2;
                achiev_pic.y = _this.positions[i * 2 + 1] - Constants.ASSETS_HEIGHT / 2;
                _this.addGameObjectAtPos(new LightEffect(Utils.RandomRange(4, 10), 8, 10, 0.3, 1), achiev_pic, Utils.RandomRangeInt(-50, 50), Utils.RandomRangeInt(-50, 50));
            }
            else {
                var fire = new AutoreleaseEffect("achievement_locked_", 12, Utils.RandomRange(0.03, 0.04), true, true);
                var proxy_fire = new createjs.Container();
                back.addChild(proxy_fire);
                _this.addGameObjectAt(fire, proxy_fire);
                _this.fires.push(proxy_fire);
                proxy_fire.x = _this.positions[i * 2] - Constants.ASSETS_WIDTH / 2;
                proxy_fire.y = _this.positions[i * 2 + 1] - Constants.ASSETS_HEIGHT / 2;
                proxy_fire.regY += 30;
                _this.fireSpeedAndAmp.push(new createjs.Point(Utils.RandomRange(1, 2), Utils.RandomRange(7, 12)));
            }
        }
        _this.alignByCenter();
        return _this;
    }
    AchievementsState.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        for (var i = 0; i < this.fires.length; i++) {
            this.fires[i].rotation = Math.sin(this.liveTime * this.fireSpeedAndAmp[i].x) * this.fireSpeedAndAmp[i].y;
        }
    };
    AchievementsState.prototype.onExitTouch = function () {
        StateManager.g_instance.pushState(new GradientInState(new MainMenuState()));
    };
    return AchievementsState;
}(GameState));
/// <reference path="references.ts" />
var GameOverState = (function (_super) {
    __extends(GameOverState, _super);
    function GameOverState(round, score) {
        var _this = _super.call(this) || this;
        _this.panel = new createjs.Container();
        _this.startAnim = false;
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        //  shading
        _this.shader = new createjs.Shape();
        _this.shader.graphics.beginFill("#000000");
        _this.shader.graphics.drawRect(0, -diff, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT + diff);
        _this.shader.graphics.endFill();
        _this.addChild(_this.shader);
        _this.shader.alpha = 0;
        _this.shaderTween = createjs.Tween.get(_this.shader, { loop: false }).wait(400).to({ alpha: 0.4 }, 800, createjs.Ease.linear);
        _this.addChild(_this.panel);
        _this.panel.x = Constants.ASSETS_WIDTH / 2;
        _this.panel.y = Constants.SCREEN_HEIGHT / 2 - diff;
        var panel = AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_MESSAGE_WINDOW);
        _this.panel.addChild(panel);
        var button_restart = new DNButton(Constants.IMAGE_BUTTON_RESTART, function () { return _this.onRestartTouch(); });
        _this.panel.addChild(button_restart);
        _this.addGuiObject(button_restart);
        button_restart.x = 0;
        button_restart.scaleX = button_restart.scaleY = 1.4;
        button_restart.y = 70;
        var button_exit = new DNButton(Constants.IMAGE_BUTTON_EXIT, function () { return _this.onExitTouch(); });
        _this.panel.addChild(button_exit);
        _this.addGuiObject(button_exit);
        button_exit.x = -150;
        button_exit.y = 120;
        var button_ach = new DNButton(Constants.IMAGE_BUTTON_ACHIEVEMENTS, function () { return _this.onAchievementsTouch(); });
        _this.panel.addChild(button_ach);
        _this.addGuiObject(button_ach);
        button_ach.x = +150;
        button_ach.y = 120;
        _this.loseCaption = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_GAMEOVER_CAPTION);
        _this.panel.addChild(_this.loseCaption);
        _this.loseCaption.y = -180;
        //----------------------------------
        var caption_x = -180;
        var digits_x = +180;
        //this.roundLabel = new DNTextField(round.toString());
        //this.panel.addChild(this.roundLabel);
        //this.roundLabel.x = digits_x - this.roundLabel.getWidth();
        //this.roundLabel.y = this.roundCaption.y;
        //this.scoreLabel = new DNTextField(score.toString());
        //this.panel.addChild(this.scoreLabel);
        //this.scoreLabel.x = digits_x - this.scoreLabel.getWidth();
        //this.scoreLabel.y = this.scoreCaption.y;
        //----------------------------------
        _this.panel.alpha = 0.0;
        createjs.Tween.get(_this.panel, { loop: false }).to({ alpha: 1 }, 200, createjs.Ease.linear);
        _this.panel.scaleX = 0.7;
        _this.panel.scaleY = 0.7;
        createjs.Tween.get(_this.panel, { loop: false }).to({ scaleX: 1, scaleY: 1 }, 400, createjs.Ease.backOut)
            .call(function () { _this.startAnim = true; _this.liveTime = 0; });
        if (enableAds == true) {
            try {
                analytics.levelFailed(PlayState.g_curLevel + 1);
                if (StateManager.g_instance.adsCD <= 0) {
                    StateManager.g_instance.restartAdsCD();
                    adSense.showAdvertising();
                }
            }
            catch (e) {
            }
        }
        return _this;
    }
    GameOverState.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        if (this.startAnim) {
            this.loseCaption.rotation = Math.sin(this.liveTime * 2) * 4;
        }
    };
    GameOverState.prototype.onRestartTouch = function () {
        if (enableAds == true) {
            try {
                if (StateManager.g_instance.adsCD <= 0) {
                    StateManager.g_instance.restartAdsCD();
                    adSense.showAdvertising();
                }
            }
            catch (e) {
            }
        }
        StateManager.g_instance.pushState(new ShadeInState(new PlayState(PlayState.g_curLevel, false)));
    };
    GameOverState.prototype.onExitTouch = function () {
        if (enableAds == true) {
            try {
                if (StateManager.g_instance.adsCD <= 0) {
                    StateManager.g_instance.restartAdsCD();
                    adSense.showAdvertising();
                }
            }
            catch (e) {
            }
        }
        StateManager.g_instance.pushState(new GradientInState(new MainMenuState()));
    };
    GameOverState.prototype.onAchievementsTouch = function () {
        StateManager.g_instance.pushState(new GradientInState(new AchievementsState()));
    };
    return GameOverState;
}(GameState));
/// <reference path="references.ts" />
var MainMenuState = (function (_super) {
    __extends(MainMenuState, _super);
    function MainMenuState() {
        var _this = _super.call(this) || this;
        _this.crystalSpeed = 0;
        _this.prevCrystalY = 0;
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        var back = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_TITLE_MAIN_MENU_BACK);
        back.x = Constants.ASSETS_WIDTH / 2;
        back.y = Constants.ASSETS_HEIGHT / 2;
        _this.addChild(back);
        var button_play = new DNButton(Constants.IMAGE_BUTTON_PLAY, function () { return _this.onPlayTouch(); });
        _this.addChild(button_play);
        _this.addGuiObject(button_play);
        button_play.x = Constants.ASSETS_WIDTH / 2;
        button_play.y = 765;
        createjs.Tween.get(button_play, { loop: true })
            .to({ scaleX: +1.05, scaleY: +1.05 }, 150, createjs.Ease.linear)
            .to({ scaleX: +0.95, scaleY: +0.95 }, 300, createjs.Ease.linear)
            .to({ scaleX: 1, scaleY: 1 }, 150, createjs.Ease.linear)
            .wait(4000);
        var button_more_games = new DNButton("button_moregames", function () { return _this.onMoreTouch(); });
        _this.addChild(button_more_games);
        _this.addGuiObject(button_more_games);
        button_more_games.x = 550;
        button_more_games.y = 780;
        button_more_games.visible = false;
        var button_achievements = new DNButton(Constants.IMAGE_BUTTON_ACHIEVEMENTS, function () { return _this.onAchievementsTouch(); });
        _this.addChild(button_achievements);
        _this.addGuiObject(button_achievements);
        button_achievements.x = 150;
        button_achievements.y = 780;
        var title = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_TITLE);
        _this.addChild(title);
        title.x = Constants.ASSETS_WIDTH / 2;
        title.y = 130;
        _this.addGameObjectAtPos(new LightEffect(3, 8, 10, 0.5, 1), title, -145, 50);
        _this.addGameObjectAtPos(new LightEffect(4.5, 8, 10, 0.5, 1), title, +125, 75);
        //------    SHAMAN
        _this.crystal = AssetsManager.g_instance.getCenteredImageWithProxy("crystal");
        _this.crystal.x = Constants.ASSETS_WIDTH / 2;
        _this.crystal.y = 460;
        _this.glow = AssetsManager.g_instance.getCenteredImageWithProxy("crystal_glow");
        _this.glow.x = Constants.ASSETS_WIDTH / 2;
        _this.glow.y = 460;
        _this.addChild(_this.glow);
        _this.addChild(_this.crystal);
        _this.glow.alpha = 0.5;
        _this.crystal.scaleX = _this.crystal.scaleY = 0.85;
        _this.glow.scaleX = _this.glow.scaleY = 0.85;
        _this.addGameObjectAtPos(new LightEffect(Utils.RandomRange(2, 7), Utils.RandomRange(4, 8), 40, 0.3, 1), _this.crystal, 83, -73);
        _this.addGameObjectAtPos(new LightEffect(Utils.RandomRange(2, 8), Utils.RandomRange(3, 8), 40, 0.3, 1), _this.crystal, -83, -75);
        _this.addGameObjectAtPos(new LightEffect(Utils.RandomRange(2, 8), Utils.RandomRange(4, 8), 40, 0.3, 1), _this.crystal, 0, -36);
        _this.addGameObjectAtPos(new LightEffect(Utils.RandomRange(2, 8), Utils.RandomRange(4, 8), 40, 0.3, 1), _this.crystal, 0, 113);
        _this.addGameObjectAtPos(new LightEffect(Utils.RandomRange(2, 7), Utils.RandomRange(3, 8), 40, 0.3, 1), _this.crystal, 40, 143);
        _this.addGameObjectAtPos(new LightEffect(Utils.RandomRange(2, 8), Utils.RandomRange(4, 8), 40, 0.3, 1), _this.crystal, -40, 141);
        //  
        _this.setSoundButton();
        _this.alignByCenter();
        try {
            analytics.menu();
        }
        catch (e) {
        }
        _this.update(0);
        return _this;
    }
    MainMenuState.prototype.onOrientationChanged = function (landscape) {
        _super.prototype.onOrientationChanged.call(this, landscape);
        if (!landscape) {
            this.alignByCenter();
        }
    };
    MainMenuState.prototype.init = function () {
        _super.prototype.init.call(this);
    };
    MainMenuState.prototype.runJelly = function () {
        this.liveTime = 0;
    };
    MainMenuState.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        this.prevCrystalY = this.crystal.y;
        this.crystal.y = 460 + Math.sin(this.liveTime * 1.2) * 12;
        this.glow.y = 460 + Math.sin(this.liveTime * 1.2) * 12;
        this.glow.alpha = 0.5 + Math.sin(this.liveTime * 3) * 0.4;
        this.crystalSpeed = (this.crystal.y - this.prevCrystalY) / dt;
    };
    MainMenuState.prototype.onSoundTouch = function () {
        SoundManager.g_instance.calcSoundEnabled(!SoundManager.g_instance.isSoundEnabled());
        this.setSoundButton();
    };
    MainMenuState.prototype.setSoundButton = function () {
        var _this = this;
        if (this.soundButton && this.soundButton.parent) {
            this.soundButton.parent.removeChild(this.soundButton);
        }
        var enabled = SoundManager.g_instance.isSoundEnabled();
        this.soundButton = new DNButton(enabled ? Constants.IMAGE_BUTTON_SOUND_ON : Constants.IMAGE_BUTTON_SOUND_OFF, function () { return _this.onSoundTouch(); });
        this.addChild(this.soundButton);
        this.addGuiObject(this.soundButton);
        this.soundButton.x = 580;
        this.soundButton.y = 280;
    };
    MainMenuState.prototype.onMoreTouch = function () {
        try {
            moregames.redirect();
        }
        catch (e) {
        }
    };
    MainMenuState.prototype.onAchievementsTouch = function () {
        StateManager.g_instance.pushState(new GradientInState(new AchievementsState()));
    };
    MainMenuState.prototype.onPlayTouch = function () {
        //StateManager.g_instance.pushState(new GradientInState(new LevelCreatorState()));
        StateManager.g_instance.pushState(new GradientInState(new SelectLevelState()));
    };
    MainMenuState.prototype.resume = function () {
        this.alignByCenter();
    };
    return MainMenuState;
}(GameState));
/// <reference path="references.ts" />
var ShadeInState = (function (_super) {
    __extends(ShadeInState, _super);
    function ShadeInState(next_state) {
        var _this = _super.call(this) || this;
        _this.nextState = null;
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        _this.nextState = next_state;
        //  shading
        _this.shader = new createjs.Shape();
        _this.shader.graphics.beginFill("#ffffff");
        _this.shader.graphics.drawRect(0, -diff, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT + diff);
        _this.shader.graphics.endFill();
        _this.addChild(_this.shader);
        _this.shader.alpha = 0;
        createjs.Tween.get(_this.shader).to({ alpha: 1.0 }, 400, createjs.Ease.linear).call(function () { return _this.onFinishShade(); });
        return _this;
    }
    ShadeInState.prototype.onFinishShade = function () {
        StateManager.g_instance.changeState(this.nextState);
        StateManager.g_instance.pushState(new ShadeOutState());
    };
    ShadeInState.prototype.setNextState = function (state) {
        this.nextState = state;
    };
    return ShadeInState;
}(GameState));
/// <reference path="references.ts" />
var ShadeOutState = (function (_super) {
    __extends(ShadeOutState, _super);
    function ShadeOutState() {
        var _this = _super.call(this) || this;
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        //  shading
        _this.shader = new createjs.Shape();
        _this.shader.graphics.beginFill("#ffffff");
        _this.shader.graphics.drawRect(0, -diff, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT + diff);
        _this.shader.graphics.endFill();
        _this.addChild(_this.shader);
        createjs.Tween.get(_this.shader).to({ alpha: 0 }, 400, createjs.Ease.linear).call(function () { return _this.onFinishShade(); });
        return _this;
    }
    ShadeOutState.prototype.onFinishShade = function () {
        StateManager.g_instance.popState();
    };
    return ShadeOutState;
}(GameState));
/// <reference path="MainMenuState.ts" />
var CreditsState = (function (_super) {
    __extends(CreditsState, _super);
    function CreditsState() {
        var _this = _super.call(this) || this;
        _this.hiddingNow = false;
        //  shading
        _this.shader = new createjs.Shape();
        _this.shader.graphics.beginFill("#ffffff");
        _this.shader.graphics.drawRect(0, 0, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT);
        _this.shader.graphics.endFill();
        _this.addChild(_this.shader);
        _this.shader.alpha = 0;
        createjs.Tween.get(_this.shader).to({ alpha: 0.82 }, 500, createjs.Ease.linear);
        _this.container = new createjs.Container();
        _this.addChild(_this.container);
        _this.container.alpha = 0;
        createjs.Tween.get(_this.container).to({ alpha: 1.0 }, 500, createjs.Ease.linear);
        var texts = [
            "PROGRAMMING / GAME DESIGN:",
            "Konstantin Boronenkov",
            "",
            "",
            "ART:",
            "Vladimir Makarov",
            "Anna Turkova",
            "",
            "",
            "MUSIC / SOUND:",
            "Alexander Ahura",
            "",
            "",
            "Hypnocat Studio 2014",
            "gibbetsfeedback@gmail.com",
        ];
        for (var i = 0; i < texts.length; i++) {
            var line = new createjs.Text(texts[i], "bold 35px Times New Roman", "#222222");
            line.textAlign = "center";
            _this.container.addChild(line);
            line.x = Constants.ASSETS_WIDTH / 2;
            line.y = 100 + i * 40;
        }
        return _this;
    }
    CreditsState.prototype.onMouseDown = function (x, y) {
        this.hide();
    };
    CreditsState.prototype.hide = function () {
        if (!this.hiddingNow) {
            createjs.Tween.removeTweens(this.shader);
            createjs.Tween.removeTweens(this.container);
            createjs.Tween.get(this.shader).to({ alpha: 0.0 }, 400, createjs.Ease.linear).call(function () { StateManager.g_instance.popState(); });
            createjs.Tween.get(this.container).to({ alpha: 0.0 }, 400, createjs.Ease.linear);
            this.hiddingNow = true;
        }
    };
    return CreditsState;
}(GameState));
/// <reference path="references.ts" />
var GameData = (function () {
    function GameData() {
        this.levelsCompleted = 0;
        this.totalScore = 0;
        this.mapEditorLevel = testLevel;
        this.levels = g_levels;
        this.achievments = 0;
        this.isLastLevelShowed = false;
        this.isNeedShowAch = false;
        this.levelsWithAchievments = [4, 8, 12, 16, 20, 24, 28, 32, 36, 40];
    }
    GameData.getInstance = function () {
        if (this.instance == null) {
            this.instance = new GameData();
        }
        return this.instance;
    };
    GameData.prototype.save = function () {
        try {
            window.localStorage.setItem("levelsCompleted", this.levelsCompleted.toString());
            window.localStorage.setItem("totalScore", this.totalScore.toString());
            window.localStorage.setItem("achievements", this.achievments.toString());
            window.localStorage.setItem("levels_with_ach", JSON.stringify(this.levelsWithAchievments));
            window.localStorage.setItem("last_level_showed", this.isLastLevelShowed.toString());
        }
        catch (e) {
        }
    };
    GameData.prototype.load = function () {
        try {
            //  unary "+" to convert string to number
            this.levelsCompleted = +window.localStorage.getItem("levelsCompleted") || 0;
            this.totalScore = +window.localStorage.getItem("totalScore") || 0;
            this.achievments = +window.localStorage.getItem("achievements") || 0;
            this.levelsWithAchievments = JSON.parse(window.localStorage.getItem("levels_with_ach"))
                || [4, 8, 12, 16, 20, 24, 28, 32, 36, 40];
            this.isLastLevelShowed = window.localStorage.getItem("last_level_showed") == "true";
        }
        catch (e) {
        }
    };
    GameData.prototype.onWinLevel = function (level, score) {
        this.totalScore += score;
        if (level == this.levelsCompleted) {
            this.levelsCompleted = level + 1;
            if (this.levelsCompleted > this.getTotalLevels()) {
                this.levelsCompleted = this.getTotalLevels();
            }
        }
        this.save();
    };
    GameData.prototype.getTotalScore = function () {
        return this.totalScore;
    };
    GameData.prototype.getLevelDef = function (level_num) {
        if (level_num == -1) {
            return this.mapEditorLevel;
        }
        return this.levels[level_num];
    };
    GameData.prototype.levelsAvailable = function () {
        if (Constants.g_DEBUG) {
            return this.getTotalLevels();
        }
        return this.levelsCompleted + 1;
    };
    GameData.prototype.getTotalLevels = function () {
        return this.levels.length;
        //return 41;
    };
    GameData.prototype.isShowedGZ = function () {
        return this.isLastLevelShowed;
    };
    GameData.prototype.onGZShowed = function () {
        this.isLastLevelShowed = true;
        this.save();
    };
    GameData.prototype.addAchievment = function () {
        this.achievments++;
        this.isNeedShowAch = true;
        this.achievments = this.achievments > 10 ? 10 : this.achievments;
        this.levelsWithAchievments.splice(0, 1);
        this.save();
    };
    GameData.prototype.onAchievementShow = function () {
        this.isNeedShowAch = false;
    };
    GameData.prototype.isLevelGotAchievement = function (num) {
        if (this.levelsWithAchievments.indexOf(num) != -1) {
            return true;
        }
        return false;
    };
    GameData.prototype.isNeedShowAchievement = function () {
        return this.isNeedShowAch;
    };
    GameData.prototype.getAchievementsNum = function () {
        return this.achievments;
    };
    return GameData;
}());
GameData.instance = null;
/// <reference path="references.ts" />
function init() {
    var manifest = [];
    var athlases = [
        {
            "images": ["art_1"],
            "frames": [
                [561, 2003, 32, 41],
                [1861, 909, 32, 41],
                [2008, 888, 32, 41],
                [2008, 845, 32, 41],
                [2008, 802, 32, 41],
                [1006, 866, 32, 41],
                [1057, 1993, 32, 41],
                [2008, 759, 32, 41],
                [384, 1807, 32, 41],
                [972, 866, 32, 41],
                [932, 1704, 185, 185],
                [945, 1517, 185, 185],
                [797, 1330, 185, 185],
                [745, 1704, 185, 185],
                [758, 1517, 185, 185],
                [558, 1704, 185, 185],
                [571, 1517, 185, 185],
                [384, 1512, 185, 185],
                [610, 1330, 185, 185],
                [281, 1325, 185, 185],
                [1231, 1240, 185, 185],
                [1044, 1240, 185, 185],
                [857, 1107, 185, 185],
                [1231, 1053, 185, 185],
                [1044, 1053, 185, 185],
                [1231, 866, 185, 185],
                [1044, 866, 185, 185],
                [857, 920, 185, 185],
                [640, 1143, 185, 185],
                [670, 956, 185, 185],
                [1418, 862, 140, 180],
                [1640, 680, 140, 180],
                [1498, 680, 140, 180],
                [1356, 680, 140, 180],
                [1261, 1791, 140, 180],
                [1119, 1791, 140, 180],
                [1274, 1609, 140, 180],
                [1132, 1609, 140, 180],
                [1274, 1427, 140, 180],
                [1132, 1427, 140, 180],
                [468, 1294, 140, 180],
                [1904, 464, 140, 180],
                [896, 1891, 105, 105],
                [561, 1891, 117, 110],
                [440, 1807, 110, 107],
                [1555, 1314, 133, 109],
                [1555, 1201, 135, 111],
                [1555, 1088, 135, 111],
                [1560, 975, 135, 111],
                [1906, 646, 135, 111],
                [1418, 1044, 135, 135],
                [1282, 248, 226, 189],
                [1418, 1294, 135, 111],
                [1418, 1181, 135, 111],
                [1560, 862, 135, 111],
                [984, 1427, 87, 88],
                [1704, 1653, 91, 91],
                [1704, 1560, 91, 91],
                [1611, 1653, 91, 91],
                [1611, 1560, 91, 91],
                [1665, 1467, 91, 91],
                [1518, 1704, 91, 91],
                [1518, 1611, 91, 91],
                [1818, 1072, 41, 104],
                [1818, 966, 41, 104],
                [1818, 860, 41, 104],
                [1863, 803, 41, 104],
                [1818, 1072, 41, 104],
                [1818, 966, 41, 104],
                [1963, 1094, 81, 81],
                [1689, 1931, 85, 85],
                [1003, 1993, 52, 53],
                [2008, 931, 38, 18],
                [2, 504, 450, 500],
                [2, 2, 450, 500],
                [789, 1891, 105, 105],
                [1887, 1852, 89, 85],
                [468, 1476, 71, 30],
                [454, 886, 214, 214],
                [1688, 464, 214, 214],
                [1472, 464, 214, 214],
                [1256, 439, 214, 214],
                [1726, 248, 214, 214],
                [1510, 248, 214, 214],
                [1774, 2, 244, 244],
                [1528, 2, 244, 244],
                [1282, 2, 244, 244],
                [1010, 428, 244, 244],
                [2, 1786, 244, 244],
                [764, 358, 244, 244],
                [2, 1540, 244, 244],
                [764, 112, 244, 244],
                [454, 640, 244, 244],
                [1854, 1944, 64, 64],
                [1208, 2, 71, 84],
                [1782, 680, 122, 121],
                [789, 604, 23, 32],
                [595, 2003, 23, 32],
                [2017, 1209, 23, 32],
                [2020, 2, 23, 32],
                [827, 1143, 23, 32],
                [610, 1294, 23, 32],
                [640, 1102, 23, 32],
                [670, 886, 23, 32],
                [764, 604, 23, 32],
                [1665, 1425, 23, 32],
                [454, 321, 308, 317],
                [1403, 1815, 100, 100],
                [1416, 1713, 100, 100],
                [1416, 1611, 100, 100],
                [1416, 1509, 100, 100],
                [1418, 1407, 100, 100],
                [1915, 1279, 100, 100],
                [1915, 1177, 100, 100],
                [1811, 1382, 100, 100],
                [1813, 1280, 100, 100],
                [1813, 1178, 100, 100],
                [1861, 1065, 100, 100],
                [1861, 963, 100, 100],
                [1906, 861, 100, 100],
                [1906, 759, 100, 100],
                [1003, 1891, 100, 100],
                [1942, 350, 100, 100],
                [1942, 248, 100, 100],
                [1073, 1427, 54, 59],
                [1963, 1048, 83, 44],
                [1164, 674, 190, 190],
                [972, 674, 190, 190],
                [448, 1102, 190, 190],
                [836, 604, 134, 314],
                [700, 640, 134, 314],
                [248, 1540, 134, 314],
                [1146, 112, 134, 314],
                [1010, 112, 134, 314],
                [312, 1006, 134, 314],
                [248, 1856, 190, 190],
                [440, 1916, 119, 119],
                [1690, 1346, 119, 119],
                [1692, 1225, 119, 119],
                [1692, 1104, 119, 119],
                [1697, 983, 119, 119],
                [1697, 862, 119, 119],
                [1518, 1518, 91, 91],
                [1520, 1425, 91, 91],
                [1782, 803, 79, 55],
                [1776, 1944, 76, 62],
                [1613, 1425, 50, 90],
                [2, 1325, 277, 213],
                [972, 604, 32, 41],
                [764, 2, 442, 108],
                [1611, 1746, 90, 91],
                [1544, 1981, 46, 58],
                [1496, 1981, 46, 58],
                [1981, 1696, 46, 58],
                [1981, 1636, 46, 58],
                [1981, 1576, 46, 58],
                [1968, 1939, 46, 58],
                [984, 1354, 46, 58],
                [984, 1294, 46, 58],
                [1920, 1939, 46, 58],
                [1758, 1467, 46, 58],
                [1963, 963, 83, 83],
                [680, 1891, 107, 107],
                [384, 1699, 172, 106],
                [1795, 1852, 90, 90],
                [1703, 1838, 90, 90],
                [1887, 1760, 90, 90],
                [1889, 1668, 90, 90],
                [1889, 1576, 90, 90],
                [1898, 1484, 90, 90],
                [1597, 1931, 90, 90],
                [1505, 1889, 90, 90],
                [1795, 1760, 90, 90],
                [1797, 1668, 90, 90],
                [1797, 1576, 90, 90],
                [1806, 1484, 90, 90],
                [1610, 1839, 90, 90],
                [1518, 1797, 90, 90],
                [1703, 1746, 90, 90],
                [1403, 1917, 91, 91],
                [1611, 1518, 32, 40],
                [2017, 1177, 29, 30],
                [2, 1006, 308, 317],
                [454, 2, 308, 317]
            ],
            "animations": {
                "0": [0],
                "1": [1],
                "2": [2],
                "3": [3],
                "4": [4],
                "5": [5],
                "6": [6],
                "7": [7],
                "8": [8],
                "9": [9],
                "achievement_1": [10],
                "achievement_10": [11],
                "achievement_10_map": [12],
                "achievement_1_map": [13],
                "achievement_2": [14],
                "achievement_2_map": [15],
                "achievement_3": [16],
                "achievement_3_map": [17],
                "achievement_4": [18],
                "achievement_4_map": [19],
                "achievement_5": [20],
                "achievement_5_map": [21],
                "achievement_6": [22],
                "achievement_6_map": [23],
                "achievement_7": [24],
                "achievement_7_map": [25],
                "achievement_8": [26],
                "achievement_8_map": [27],
                "achievement_9": [28],
                "achievement_9_map": [29],
                "achievement_locked_0": [30],
                "achievement_locked_1": [31],
                "achievement_locked_10": [32],
                "achievement_locked_11": [33],
                "achievement_locked_2": [34],
                "achievement_locked_3": [35],
                "achievement_locked_4": [36],
                "achievement_locked_5": [37],
                "achievement_locked_6": [38],
                "achievement_locked_7": [39],
                "achievement_locked_8": [40],
                "achievement_locked_9": [41],
                "bomb_bonus": [42],
                "bush_1": [43],
                "bush_2": [44],
                "button_achievements": [45],
                "button_close": [46],
                "button_credits": [47],
                "button_exit": [48],
                "button_moregames": [49],
                "button_pause": [50],
                "button_play": [51],
                "button_restart": [52],
                "button_sound_off": [53],
                "button_sound_on": [54],
                "cage": [55],
                "cake_1": [56],
                "cake_2": [57],
                "cake_3": [58],
                "cake_4": [59],
                "cake_5": [60],
                "cake_6": [61],
                "cake_7": [62],
                "chain_0": [63],
                "chain_1": [64],
                "chain_2": [65],
                "chain_3": [66],
                "chain_4": [67],
                "chain_5": [68],
                "cross_bonus": [69],
                "cross_bonus_gui": [70],
                "cross_bonus_p1": [71],
                "cross_bonus_p2": [72],
                "crystal": [73],
                "crystal_glow": [74],
                "dirt": [75],
                "donut": [76],
                "drop": [77],
                "explosion_0": [78],
                "explosion_1": [79],
                "explosion_2": [80],
                "explosion_3": [81],
                "explosion_4": [82],
                "explosion_5": [83],
                "explosion_big_0": [84],
                "explosion_big_1": [85],
                "explosion_big_2": [86],
                "explosion_big_3": [87],
                "explosion_big_4": [88],
                "explosion_big_5": [89],
                "explosion_big_6": [90],
                "explosion_big_7": [91],
                "explosion_big_8": [92],
                "fill": [93],
                "first_level_hint": [94],
                "flash": [95],
                "font_0": [96],
                "font_1": [97],
                "font_2": [98],
                "font_3": [99],
                "font_4": [100],
                "font_5": [101],
                "font_6": [102],
                "font_7": [103],
                "font_8": [104],
                "font_9": [105],
                "gameover_caption": [106],
                "gold_0": [107],
                "gold_1": [108],
                "gold_10": [109],
                "gold_11": [110],
                "gold_12": [111],
                "gold_13": [112],
                "gold_14": [113],
                "gold_15": [114],
                "gold_16": [115],
                "gold_2": [116],
                "gold_3": [117],
                "gold_4": [118],
                "gold_5": [119],
                "gold_6": [120],
                "gold_7": [121],
                "gold_8": [122],
                "gold_9": [123],
                "heart_particle": [124],
                "hint_arrow": [125],
                "level_button": [126],
                "level_button_down": [127],
                "level_button_flag": [128],
                "lighting_0": [129],
                "lighting_1": [130],
                "lighting_2": [131],
                "lighting_3": [132],
                "lighting_4": [133],
                "lighting_5": [134],
                "lock": [135],
                "match_effect_0": [136],
                "match_effect_1": [137],
                "match_effect_2": [138],
                "match_effect_3": [139],
                "match_effect_4": [140],
                "match_effect_5": [141],
                "obtacle_1": [142],
                "obtacle_2": [143],
                "obtacle_part_0": [144],
                "obtacle_part_1": [145],
                "obtacle_part_2": [146],
                "out_of_moves": [147],
                "p": [148],
                "pause_panel": [149],
                "score_bonus": [150],
                "sel_0": [151],
                "sel_1": [152],
                "sel_2": [153],
                "sel_3": [154],
                "sel_4": [155],
                "sel_5": [156],
                "sel_6": [157],
                "sel_7": [158],
                "sel_8": [159],
                "sel_9": [160],
                "shaman_bonus": [161],
                "shining": [162],
                "sickle": [163],
                "stone_0": [164],
                "stone_1": [165],
                "stone_10": [166],
                "stone_11": [167],
                "stone_12": [168],
                "stone_13": [169],
                "stone_14": [170],
                "stone_2": [171],
                "stone_3": [172],
                "stone_4": [173],
                "stone_5": [174],
                "stone_6": [175],
                "stone_7": [176],
                "stone_8": [177],
                "stone_9": [178],
                "stone_heart": [179],
                "stone_part_1": [180],
                "stone_part_2": [181],
                "win_caption": [182],
                "win_caption_eyes": [183]
            }
        },
        {
            "images": ["art_2"],
            "frames": [
                [501, 2, 700, 352],
                [2, 2, 497, 479],
                [501, 356, 700, 154],
                [1203, 2, 700, 184],
                [1203, 188, 620, 201]
            ],
            "animations": {
                "gui": [0],
                "message_window": [1],
                "select_level_back": [2],
                "task_panel": [3],
                "title": [4]
            }
        },
        {
            "images": ["digits_font"],
            "frames": [
                [1, 11, 28, 29],
                [30, 1, 39, 50],
                [70, 2, 23, 47],
                [94, 2, 36, 50],
                [131, 1, 35, 48],
                [167, 2, 41, 47],
                [209, 2, 36, 49],
                [1, 53, 36, 50],
                [38, 55, 37, 47],
                [76, 54, 35, 48],
                [112, 53, 36, 50]
            ],
            "animations": {
                "digits_font_+": [0],
                "digits_font_0": [1],
                "digits_font_1": [2],
                "digits_font_2": [3],
                "digits_font_3": [4],
                "digits_font_4": [5],
                "digits_font_5": [6],
                "digits_font_6": [7],
                "digits_font_7": [8],
                "digits_font_8": [9],
                "digits_font_9": [10]
            }
        },
    ];
    var jpg = [
        "map_1",
        "map_2",
        "map_3",
        "map_4",
        "map_5",
        Constants.IMAGE_TITLE_MAIN_MENU_BACK,
        "back",
        "achievements_back"
    ];
    var art = [
        Constants.IMAGE_TITLE_MAIN_MENU_BACK,
        "back",
        Constants.IMAGE_ROTATE,
        "achievements_back",
        "map_1",
        "map_2",
        "map_3",
        "map_4",
        "map_5",
        "black_square",
        "gradient"
    ];
    var sound = [
        SoundManager.SOUND_MUSIC,
        SoundManager.SOUND_CLICK,
        SoundManager.SOUND_MATCH_1,
        SoundManager.SOUND_MATCH_2,
        SoundManager.SOUND_MATCH_3,
        SoundManager.SOUND_MATCH_4,
        SoundManager.SOUND_MATCH_5,
        SoundManager.SOUND_DROP_1,
        SoundManager.SOUND_DROP_2,
        SoundManager.SOUND_DROP_3,
        SoundManager.SOUND_LINE,
        SoundManager.SOUND_KILL_COLOR,
        SoundManager.SOUND_BOOM,
        SoundManager.SOUND_AWESOME,
        SoundManager.SOUND_EXCHANGE,
        SoundManager.SOUND_WIN,
        SoundManager.SOUND_LOSE,
        SoundManager.SOUND_VERTICAL_LIGHTING,
        SoundManager.SOUND_SHAMAN,
    ];
    for (var i = 0; i < athlases.length; i++) {
        art.push(athlases[i]["images"][0]);
    }
    for (var i = 0; i < art.length; i++) {
        if (jpg.indexOf(art[i]) == -1) {
            manifest.push({ src: "assets/art/" + art[i] + ".png", id: art[i] });
        }
        else {
            manifest.push({ src: "assets/art/" + art[i] + ".jpg", id: art[i] });
        }
    }
    createjs.Sound.alternateExtensions = ["mp3"];
    var sound_manifest = [];
    for (var i = 0; i < sound.length; i++) {
        sound_manifest.push({ src: sound[i] + ".ogg", id: sound[i] });
    }
    Constants.g_isPC = !Utils.IsMobileBrowser();
    new StateManager(manifest, sound_manifest, athlases, []);
}
;
/// <reference path="references.ts" />
var GUIObject = (function (_super) {
    __extends(GUIObject, _super);
    function GUIObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GUIObject.prototype.onMouseDown = function (x, y) {
    };
    GUIObject.prototype.onMouseUp = function (x, y) {
    };
    GUIObject.prototype.onMouseMove = function (x, y) {
    };
    GUIObject.prototype.setHandler = function (callback) {
        //  do nothing
    };
    return GUIObject;
}(GameObject));
GUIObject.wasHandlerThisFrame = false;
/// <reference path="references.ts" />
var DNTextField = (function (_super) {
    __extends(DNTextField, _super);
    function DNTextField(text, font_name, letter_dist) {
        var _this = _super.call(this) || this;
        _this.textWidth = 0;
        _this.fontNamePrefix = "";
        _this.letterDistance = 0;
        if (font_name) {
            _this.fontNamePrefix = font_name;
        }
        if (letter_dist) {
            _this.letterDistance = letter_dist;
        }
        _this.setText(text);
        return _this;
    }
    DNTextField.prototype.setColor = function (r, g, b) {
        this.filters = [new createjs.ColorFilter(1, 1, 1, 1, r - 256, g - 256, b - 256, 0)];
        this.cache(0, 0, this.getBounds().width, this.getBounds().height, 1);
    };
    DNTextField.prototype.setText = function (text) {
        this.removeAllChildren();
        var x_offset = 0;
        for (var i = 0; i < text.length; i++) {
            var char_code = text.charAt(i);
            var ch = AssetsManager.g_instance.getImage(this.fontNamePrefix + char_code);
            this.addChild(ch);
            ch.x = x_offset;
            x_offset += ch.getBounds().width + this.letterDistance;
        }
        this.textWidth = x_offset;
    };
    DNTextField.prototype.getWidth = function () {
        return this.textWidth;
    };
    return DNTextField;
}(createjs.Container));
/// <reference path="references.ts" />
var FlyingPoints = (function (_super) {
    __extends(FlyingPoints, _super);
    function FlyingPoints(value) {
        var _this = _super.call(this) || this;
        _this.label = new BitmapLabelPoints(Fonts.font_digits, "+" + value.toString());
        _this.addChild(_this.label);
        return _this;
    }
    FlyingPoints.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        this.y -= dt * 150;
        if (this.liveTime > 0.5) {
            this.alpha -= dt * 3.5;
        }
        if (this.liveTime >= 1.5) {
            this.kill();
        }
    };
    return FlyingPoints;
}(GameObject));
/// <reference path="references.ts" />
var ConvertToBonusEffect = (function (_super) {
    __extends(ConvertToBonusEffect, _super);
    function ConvertToBonusEffect(chip) {
        var _this = _super.call(this) || this;
        _this.chip = chip;
        _this.addChild(AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_SHINING));
        _this.scaleX = _this.scaleY = 2.5;
        return _this;
    }
    ConvertToBonusEffect.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        this.rotation += dt * Math.PI * 35;
        if (this.scaleX > 1) {
            this.scaleX -= dt * 3;
            this.scaleY -= dt * 3;
        }
        if (this.chip.isMatching()) {
            this.alpha -= dt * 4;
        }
        this.x = this.chip.x;
        this.y = this.chip.y;
        if (this.chip.isDead()) {
            this.kill();
        }
    };
    return ConvertToBonusEffect;
}(GameObject));
/// <reference path="references.ts" />
var KillLineEffect = (function (_super) {
    __extends(KillLineEffect, _super);
    function KillLineEffect(speed) {
        var _this = _super.call(this) || this;
        _this.speed = speed;
        _this.addChild(AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_SICKLE));
        if (speed.x < 0) {
            _this.rotation = 180;
        }
        if (speed.x > 0) {
            _this.rotation = 0;
        }
        if (speed.y < 0) {
            _this.rotation = -90;
        }
        if (speed.y > 0) {
            _this.rotation = +90;
        }
        return _this;
    }
    KillLineEffect.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        this.x += dt * this.speed.x;
        this.y += dt * this.speed.y;
        if (this.x > Constants.ASSETS_WIDTH + 172 / 2) {
            this.kill();
        }
        if (this.x < -172 / 2) {
            this.kill();
        }
        if (this.y < 300 && this.speed.y < 0) {
            this.alpha -= dt * 6;
        }
        if (this.y < -106 / 2) {
            this.kill();
        }
        if (this.y > Constants.SCREEN_HEIGHT + 106 / 2) {
            this.kill();
        }
    };
    return KillLineEffect;
}(GameObject));
/// <reference path="references.ts" />
var KillColorEffect = (function (_super) {
    __extends(KillColorEffect, _super);
    function KillColorEffect(from, to) {
        var _this = _super.call(this) || this;
        var speed = 2000;
        _this.addChild(AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_DROP));
        var dir = new createjs.Point(to.x - from.x, to.y - from.y);
        _this.distance = Math.sqrt(dir.x * dir.x + dir.y * dir.y);
        _this.maxTime = _this.distance / speed;
        var cos = dir.x / _this.distance;
        _this.speed = new createjs.Point(dir.x / _this.distance * speed, dir.y / _this.distance * speed);
        //this.rotation = -Utils.RadToGrad(Math.acos(cos));
        _this.rotation = Utils.RadToGrad(Math.atan2(dir.y, dir.x));
        return _this;
    }
    KillColorEffect.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        if (this.liveTime < this.maxTime) {
            this.x += dt * this.speed.x;
            this.y += dt * this.speed.y;
        }
        else {
            this.alpha -= dt * 3.5;
            if (this.alpha <= 0) {
                this.kill();
            }
        }
    };
    return KillColorEffect;
}(GameObject));
/// <reference path="references.ts" />
var TimeIsUpEffect = (function (_super) {
    __extends(TimeIsUpEffect, _super);
    function TimeIsUpEffect(image_name) {
        var _this = _super.call(this) || this;
        _this.stage = 0;
        _this.addChild(AssetsManager.g_instance.getCenteredImage(image_name));
        _this.x = 350;
        _this.y = 400;
        _this.setScale(0);
        _this.alpha = -1;
        return _this;
    }
    TimeIsUpEffect.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        switch (this.stage) {
            case 0:
                {
                    this.alpha += dt * 4.0;
                    this.setScale(this.scaleX + dt * 2);
                    if (this.scaleX > 1.0) {
                        this.setScale(1);
                        this.alpha = 1;
                        this.liveTime = 0;
                        this.stage = 1;
                        createjs.Tween.get(this, { loop: false }).wait(1400).to({ alpha: 0 }, 500, createjs.Ease.linear);
                    }
                }
                break;
            case 1:
                {
                    this.setScale(1.0 + Math.sin(this.liveTime * 5.0) * 0.07);
                }
                break;
        }
    };
    TimeIsUpEffect.prototype.setScale = function (scale) {
        this.scaleX = this.scaleY = scale;
    };
    return TimeIsUpEffect;
}(GameObject));
/// <reference path="references.ts" />
var MoveHint = (function (_super) {
    __extends(MoveHint, _super);
    function MoveHint(vertical) {
        var _this = _super.call(this) || this;
        _this.arrow1 = new createjs.Container();
        _this.arrow2 = new createjs.Container();
        _this.hidding = false;
        var arrow_1_bitmap = AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_HINT_ARROW);
        _this.arrow1.addChild(arrow_1_bitmap);
        _this.addChild(_this.arrow1);
        _this.arrow1.y -= 18;
        var arrow_2_bitmap = AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_HINT_ARROW);
        _this.arrow2.addChild(arrow_2_bitmap);
        _this.addChild(_this.arrow2);
        _this.arrow2.y += 18;
        _this.arrow2.rotation = 180;
        if (vertical) {
            _this.rotation = 90;
        }
        _this.alpha = 0;
        return _this;
    }
    MoveHint.prototype.update = function (dt) {
        if (this.liveTime <= 0.5) {
            this.alpha = this.liveTime * 2;
        }
        _super.prototype.update.call(this, dt);
        this.arrow1.x = Math.sin(this.liveTime * 7) * 5;
        this.arrow2.x = -this.arrow1.x;
        if (this.liveTime > 20.0) {
            this.hide();
        }
        if (this.hidding) {
            this.alpha -= dt * 3.0;
            if (this.alpha <= 0) {
                this.kill();
            }
        }
    };
    MoveHint.prototype.hide = function () {
        this.hidding = true;
    };
    return MoveHint;
}(GameObject));
/// <reference path="references.ts" />
var TutorialHighlighter = (function (_super) {
    __extends(TutorialHighlighter, _super);
    function TutorialHighlighter(left, top, right, bottom) {
        var _this = _super.call(this) || this;
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        var shape = new createjs.Shape();
        shape.graphics.beginFill("#000000");
        shape.graphics.drawRect(0, -diff - 60, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT + diff + 100);
        shape.graphics.endFill();
        _this.addChild(shape);
        var hole = new createjs.Shape();
        hole.graphics.beginFill("#000000");
        hole.graphics.drawRect(left, top, right - left, bottom - top);
        hole.graphics.endFill();
        _this.addChild(hole);
        hole.compositeOperation = "destination-out";
        //shape.mask = hole;
        _this.cache(0, -diff - 60, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT + diff + 100);
        _this.alpha = 0.0;
        createjs.Tween.get(_this).wait(300).to({ alpha: 0.65 }, 600, createjs.Ease.linear);
        return _this;
    }
    TutorialHighlighter.prototype.hide = function () {
        var _this = this;
        createjs.Tween.get(this).to({ alpha: 0 }, 400, createjs.Ease.linear).call(function () { return _this.kill(); });
    };
    return TutorialHighlighter;
}(GameObject));
/// <reference path="references.ts" />
var Tutorial = (function (_super) {
    __extends(Tutorial, _super);
    function Tutorial() {
        var _this = _super.call(this) || this;
        _this.stage = 0;
        _this.text = null;
        _this.stage1Layout = [
            [1, 2, 3, 4, 5, 1, 2],
            [2, 3, 4, 5, 1, 2, 3],
            [5, 1, 5, 3, 4, 3, 4],
            [2, 3, 2, 1, 1, 5, 5],
            [4, 5, 1, 2, 3, 2, 1],
            [1, 2, 3, 4, 2, 1, 2],
            [3, 4, 5, 1, 5, 3, 4]
        ];
        _this.stage1LayoutAccessible = [
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 1, 1, 0, 0],
            [0, 0, 1, 1, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
        ];
        _this.stage2LayoutAccessible = [
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
        ];
        _this.stage3LayoutAccessible = [
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 1, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
        ];
        _this.stage4LayoutAccessible = [
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 1, 0, 0],
        ];
        return _this;
    }
    Tutorial.prototype.onStartRound = function () {
        // PlayState.g_instance.spawnDefinedChips(this.stage1Layout);
        this.onMatch();
    };
    Tutorial.prototype.onMatch = function () {
        this.stage++;
        if (this.highlighter) {
            this.highlighter.hide();
            this.highlighter = null;
        }
        if (this.text) {
            this.text.parent.removeChild(this.text);
            this.text = null;
        }
        if (this.stage == 1) {
            this.highlighter = PlayState.g_instance.highlightArea(2, 3, 5, 5);
            this.setHintIndeces();
            this.text = new TextBox(StringManager.getInstance().getString(StringManager.TUTORIAL_1), 500, 100);
            this.text.x = 300;
            this.text.y = 330;
            this.text.scaleX = this.text.scaleY = 0.7;
            this.text.alpha = 0;
            PlayState.g_instance.addChild(this.text);
            createjs.Tween.get(this.text, { loop: false }).wait(1000).to({ alpha: 1.0 }, 600, createjs.Ease.linear);
        }
        if (this.stage == 2) {
            this.highlighter = PlayState.g_instance.highlightArea(4, 4, 5, 6);
            this.setHintIndeces();
            this.text = new TextBox(StringManager.getInstance().getString(StringManager.TUTORIAL_2), 500, 150);
            this.text.x = 420;
            this.text.y = 370;
            this.text.scaleX = this.text.scaleY = 0.7;
            this.text.alpha = 0;
            PlayState.g_instance.addChild(this.text);
            createjs.Tween.get(this.text, { loop: false }).wait(1000).to({ alpha: 1.0 }, 600, createjs.Ease.linear);
        }
        if (this.stage == 3) {
            this.highlighter = PlayState.g_instance.highlightArea(3, 4, 5, 5);
            this.setHintIndeces();
            this.text = new TextBox(StringManager.getInstance().getString(StringManager.TUTORIAL_3), 500, 150);
            this.text.x = Constants.ASSETS_WIDTH / 2;
            this.text.y = 350;
            this.text.scaleX = this.text.scaleY = 0.7;
            this.text.alpha = 0;
            PlayState.g_instance.addChild(this.text);
            createjs.Tween.get(this.text, { loop: false }).wait(1000).to({ alpha: 1.0 }, 600, createjs.Ease.linear);
        }
        if (this.stage == 4) {
            this.highlighter = PlayState.g_instance.highlightArea(4, 5, 5, 7);
            this.setHintIndeces();
            this.text = new TextBox(StringManager.getInstance().getString(StringManager.TUTORIAL_4), 500, 150);
            this.text.x = Constants.ASSETS_WIDTH / 2 + 50;
            this.text.y = 440;
            this.text.alpha = 0;
            this.text.scaleX = this.text.scaleY = 0.7;
            PlayState.g_instance.addChild(this.text);
            PlayState.g_instance.convertChipToBonusCross(4, 5);
            PlayState.g_instance.convertChipToBonusCross(4, 6);
            createjs.Tween.get(this.text, { loop: false }).wait(1000).to({ alpha: 1.0 }, 600, createjs.Ease.linear);
        }
        if (this.stage == 5) {
            this.highlighter = PlayState.g_instance.highlightArea(4, 5, 5, 7);
            this.text = new TextBox(StringManager.getInstance().getString(StringManager.TUTORIAL_5), 500, 100);
            this.text.x = Constants.ASSETS_WIDTH / 2 + 50;
            this.text.y = 440;
            this.text.alpha = 0;
            this.text.scaleX = this.text.scaleY = 0.7;
            PlayState.g_instance.addChild(this.text);
            createjs.Tween.get(this.text, { loop: false }).wait(1000).to({ alpha: 1.0 }, 600, createjs.Ease.linear);
            this.setHintIndeces();
        }
    };
    Tutorial.prototype.setHintIndeces = function () {
        switch (this.stage) {
            case 1:
                PlayState.g_instance.setHintIndeces(2, 3, 2, 4);
                break;
            case 2:
                PlayState.g_instance.setHintIndeces(4, 4, 4, 5);
                break;
            case 3:
                PlayState.g_instance.setHintIndeces(3, 4, 4, 4);
                break;
            case 4:
                PlayState.g_instance.setHintIndeces(4, 5, 4, 6);
                break;
            case 5:
                PlayState.g_instance.setHintIndeces(4, 5, 4, 6);
                break;
        }
    };
    Tutorial.prototype.isAccessibleChip = function (chip) {
        if (!this.highlighter) {
            return true;
        }
        if (this.stage == 1) {
            return this.stage1LayoutAccessible[chip.getIndexY()][chip.getIndexX()] != 0;
        }
        if (this.stage == 2) {
            return this.stage2LayoutAccessible[chip.getIndexY()][chip.getIndexX()] != 0;
        }
        if (this.stage == 3) {
            return this.stage3LayoutAccessible[chip.getIndexY()][chip.getIndexX()] != 0;
        }
        if (this.stage == 4) {
            return this.stage4LayoutAccessible[chip.getIndexY()][chip.getIndexX()] != 0;
        }
        if (this.stage == 5) {
            return this.stage4LayoutAccessible[chip.getIndexY()][chip.getIndexX()] != 0;
        }
        return true;
    };
    Tutorial.prototype.onDead = function () {
        _super.prototype.onDead.call(this);
        if (this.highlighter) {
            this.highlighter.hide();
        }
        if (this.text) {
            this.text.parent.removeChild(this.text);
            this.text = null;
        }
    };
    return Tutorial;
}(GameObject));
/// <reference path="references.ts" />
var PortraitLockState = (function (_super) {
    __extends(PortraitLockState, _super);
    function PortraitLockState() {
        var _this = _super.call(this) || this;
        _this.scaleX = _this.scaleY = 1 / Constants.SCREEN_SCALE;
        var w = window.innerWidth * Constants.PIXEL_RATIO;
        var h = window.innerHeight * Constants.PIXEL_RATIO;
        //  shading
        var shader = new createjs.Shape();
        shader.graphics.beginFill("#4aa4c2");
        shader.graphics.drawRect(0, 0, w, h);
        shader.graphics.endFill();
        _this.addChild(shader);
        var bitmap = AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_ROTATE);
        var proxy = new createjs.Container();
        _this.addChild(proxy);
        proxy.addChild(bitmap);
        proxy.x = w / 2;
        proxy.y = h / 2;
        return _this;
    }
    PortraitLockState.prototype.onOrientationChanged = function (landscape) {
        if (!landscape) {
            StateManager.g_instance.popState();
        }
    };
    return PortraitLockState;
}(GameState));
/// <reference path="references.ts" />
var SelectLevelState = (function (_super) {
    __extends(SelectLevelState, _super);
    function SelectLevelState() {
        var _this = _super.call(this) || this;
        _this.animState = 0;
        _this.touchPointY = 0;
        _this.layer = new createjs.Container();
        _this.tween = null;
        _this.ySpeed = 0;
        _this.yAcc = 1000;
        _this.calcSpeedCache = 0;
        _this.slidePositions = new Array();
        //private static needShowAnim: boolean = true;
        _this.levelsPositions = [
            90, 4420,
            240, 4300,
            360, 4400,
            565, 4245,
            360, 4110,
            120, 4007,
            340, 3900,
            560, 3815,
            330, 3700,
            140, 3700,
            260, 3450,
            480, 3445,
            620, 3330,
            375, 3275,
            130, 3180,
            110, 2970,
            300, 3060,
            480, 3090,
            600, 2900,
            375, 2800,
            135, 2535,
            120, 2365,
            355, 2400,
            525, 2525,
            595, 2345,
            340, 2225,
            580, 2115,
            520, 1950,
            340, 1960,
            135, 1900,
            240, 1660,
            430, 1660,
            570, 1520,
            370, 1415,
            210, 1450,
            95, 1335,
            200, 1160,
            325, 1250,
            455, 1105,
            360, 1000,
            165, 735,
            450, 735,
            325, 625,
            560, 480,
            330, 455,
            130, 400,
            510, 165,
            180, 95
        ];
        _this.achievementsCoords = [
            505, 4315,
            500, 3740,
            385, 3470,
            190, 3010,
            445, 2840,
            440, 2510,
            450, 1975,
            360, 1700,
            210, 1310,
            265, 995
        ];
        _this.animDelay = 0.5;
        _this.isAllUnlocked = false;
        _this.achShowed = false;
        _this.gzDelay = 0.7;
        _this.rotateTime = 2.3;
        _this.shineRotating = false;
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        //  bubbling
        var button_exit = new DNButton(Constants.IMAGE_BUTTON_EXIT, function () { return _this.onExitTouch(); });
        _this.addGuiObject(button_exit);
        _this.buttonAchievement = new DNButton(Constants.IMAGE_BUTTON_ACHIEVEMENTS, function () { return _this.onAchievementsTouch(); });
        _this.addGuiObject(_this.buttonAchievement);
        _this.addChild(_this.layer);
        _this.levelsNum = GameData.getInstance().getTotalLevels(); //GameData.getInstance().getTotalLevels();
        var levels_on_cycle = 49;
        var num_of_pics = 0;
        for (var level_num = _this.levelsNum; level_num > 0;) {
            num_of_pics++;
            level_num = level_num - levels_on_cycle;
        }
        _this.mapH = 0;
        for (var i = 0; i < 5 * num_of_pics; i++) {
            var map = AssetsManager.g_instance.getImage("map_" + (5 - i % 5));
            _this.layer.addChild(map);
            map.y = _this.mapH;
            _this.mapH += 900;
        }
        //this.layer.y = -10000;
        _this.isAllUnlocked = GameData.getInstance().getTotalLevels() == GameData.getInstance().levelsAvailable() - 1;
        var map_height = 4500 * (num_of_pics - 1), level_counter = 0;
        var button;
        var last_level;
        for (var i = 0; i < _this.levelsNum; i++) {
            button = new SelectLevelButton(Constants.IMAGE_LEVEL_BUTTON, null, i);
            _this.addGuiObject(button);
            _this.layer.addChild(button);
            button.x = (_this.levelsPositions[(i - level_counter) * 2]);
            button.y = (_this.levelsPositions[(i - level_counter) * 2 + 1] + map_height);
            if (button.isAvailable()) {
                last_level = button;
            }
            if (i % (_this.levelsPositions.length / 2) == 0 && i != 0) {
                level_counter += levels_on_cycle;
                map_height -= 4500;
                button = new SelectLevelButton(Constants.IMAGE_LEVEL_BUTTON, null, i);
                _this.addGuiObject(button);
                _this.layer.addChild(button);
                button.x = (_this.levelsPositions[(i - level_counter) * 2]);
                button.y = (_this.levelsPositions[(i - level_counter) * 2 + 1] + map_height);
            }
        }
        for (var i = 0; i < GameData.getInstance().getAchievementsNum(); i++) {
            if (GameData.getInstance().isNeedShowAchievement() && (i + 1) == GameData.getInstance().getAchievementsNum()) {
                _this.achNum = GameData.getInstance().getAchievementsNum().valueOf() - 1;
                break;
            }
            var ach = AssetsManager.g_instance.getCenteredImageWithProxy("achievement_" + (i + 1) + "_map");
            ach.x = _this.achievementsCoords[i * 2];
            ach.y = _this.achievementsCoords[i * 2 + 1];
            _this.layer.addChild(ach);
        }
        var title = AssetsManager.g_instance.getImage(Constants.IMAGE_SELECT_LEVEL_BACK);
        title.y -= diff;
        _this.addChild(title);
        var total_score_text = new BitmapLabel(StringManager.getInstance().getString(StringManager.TOTAL_SCORE));
        total_score_text.x = 280;
        total_score_text.y = 12 - diff;
        total_score_text.alignH = DN_TEXT_ALIGN_HOR.CENTER;
        total_score_text.alignW = DN_TEXT_ALIGN_VERT.MIDDLE;
        total_score_text.scaleX = total_score_text.scaleY = 0.7;
        _this.addChild(total_score_text);
        var total_score_label = new BitmapLabel(Utils.GetScoreString(GameData.getInstance().getTotalScore()));
        total_score_label.x = 450;
        total_score_label.y = 12 - diff;
        total_score_label.alignH = DN_TEXT_ALIGN_HOR.CENTER;
        total_score_label.alignW = DN_TEXT_ALIGN_VERT.MIDDLE;
        total_score_label.scaleX = total_score_label.scaleY = 0.7;
        _this.addChild(total_score_label);
        _this.addChild(button_exit);
        button_exit.x = 76;
        button_exit.y = 55 - diff;
        button_exit.scaleX = button_exit.scaleY = 0.85;
        _this.addChild(_this.buttonAchievement);
        _this.buttonAchievement.x = 625;
        _this.buttonAchievement.y = 55 - diff;
        _this.buttonAchievement.scaleX = _this.buttonAchievement.scaleY = 0.85;
        _this.buttonAchPos = new createjs.Point(_this.buttonAchievement.x, _this.buttonAchievement.y);
        if (true) {
            _this.hintArrow = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_FIRST_LEVEL_HINT);
            _this.layer.addChild(_this.hintArrow);
        }
        _this.layer.y = +Constants.ASSETS_HEIGHT / 2 - last_level.y;
        _this.update(0);
        return _this;
    }
    SelectLevelState.prototype.onExitTouch = function () {
        StateManager.g_instance.pushState(new GradientInState(new MainMenuState()));
    };
    SelectLevelState.prototype.onAchievementsTouch = function () {
        StateManager.g_instance.pushState(new GradientInState(new AchievementsState()));
    };
    SelectLevelState.prototype.onMouseDown = function (x, y) {
        _super.prototype.onMouseDown.call(this, x, y);
        if (GameData.getInstance().isNeedShowAchievement() && this.animDelay <= 0 && !this.achShowed) {
            return;
        }
        this.touchPointY = this.layer.y - y;
        this.slidePositions.length = 0;
        this.slidePositions.push({ liveTime: this.liveTime, y: y });
    };
    SelectLevelState.prototype.update = function (dt) {
        var _this = this;
        _super.prototype.update.call(this, dt);
        if (GameData.getInstance().isNeedShowAchievement()) {
            if (this.animDelay <= 0 && !this.achShowed) {
                this.achShowed = true;
                this.hideArrow();
                StateManager.g_instance.pushState(new UnlockAchievmentState(function () { _this.showAchievement(); }));
            }
            else if (this.animDelay > 0 && !this.achShowed) {
                this.animDelay -= dt;
            }
        }
        if (!GameData.getInstance().isShowedGZ() && this.isAllUnlocked) {
            if (this.gzDelay > 0) {
                this.gzDelay -= dt;
            }
            else {
                this.gzDelay = 0;
                GameData.getInstance().onGZShowed();
                StateManager.g_instance.pushState(new GratzState());
            }
        }
        if (!StateManager.g_instance.isMouseDownNow()) {
            if (this.ySpeed != 0) {
                this.layer.y += this.ySpeed * dt;
                if (this.ySpeed > 0) {
                    this.ySpeed -= dt * this.yAcc;
                    if (this.ySpeed < 0) {
                        this.ySpeed = 0;
                    }
                }
                else {
                    this.ySpeed += dt * this.yAcc;
                    if (this.ySpeed > 0) {
                        this.ySpeed = 0;
                    }
                }
            }
        }
        this.checkConstrains();
    };
    SelectLevelState.prototype.hideArrow = function () {
        createjs.Tween.get(this.hintArrow).to({ alpha: 0 }, 200);
    };
    SelectLevelState.prototype.showArrow = function () {
        this.layer.addChild(this.hintArrow);
        createjs.Tween.get(this.hintArrow).to({ alpha: 1 }, 200);
        createjs.Tween.get(this.shining).to({ alpha: 0 }, 300);
    };
    SelectLevelState.prototype.showAchievement = function () {
        //this.achNum = 3;
        var ach = AssetsManager.g_instance.getCenteredImageWithProxy("achievement_" + (this.achNum + 1) + "_map");
        ach.alpha = 0;
        this.shining = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_SHINING);
        this.shining.x = this.achievementsCoords[this.achNum * 2];
        this.shining.y = this.achievementsCoords[this.achNum * 2 + 1];
        this.layer.addChild(this.shining);
        this.shining.alpha = 0;
        this.shining.scaleX = this.shining.scaleY = 0;
        createjs.Tween.get(this.shining).wait(300).to({ alpha: 1 }, 300, createjs.Ease.linear);
        ach.scaleX = ach.scaleY = 0;
        createjs.Tween.get(ach).to({ alpha: 1 }, 300, createjs.Ease.linear);
        createjs.Tween.get(ach).wait(100).to({ scaleX: 1.2, scaleY: 1.2 }, 200, createjs.Ease.circOut)
            .to({ scaleX: 1, scaleY: 1 }, 200, createjs.Ease.circOut);
        createjs.Tween.get(this.shining).wait(300).to({ scaleX: 1.3, scaleY: 1.3 }, 300, createjs.Ease.circOut);
        ach.x = this.achievementsCoords[this.achNum * 2];
        ach.y = this.achievementsCoords[this.achNum * 2 + 1];
        this.layer.addChild(ach);
        this.rotateShineABit();
    };
    SelectLevelState.prototype.rotateShineABit = function () {
        this.shineRotating = true;
    };
    SelectLevelState.prototype.forceUpdate = function (dt) {
        _super.prototype.forceUpdate.call(this, dt);
        if (this.shineRotating) {
            this.shining.rotation += 10 * dt;
            if (this.rotateTime > 0) {
                this.rotateTime -= dt;
            }
            else {
                this.shineRotating = false;
                this.showArrow();
            }
        }
        if (this.hintArrow) {
            this.hintArrow.x = this.levelsPositions[(GameData.getInstance().levelsAvailable() - 1) * 2];
            this.hintArrow.y = this.levelsPositions[(GameData.getInstance().levelsAvailable() - 1) * 2 + 1] + Math.sin(this.liveTime * 6) * 8 - 150;
        }
    };
    SelectLevelState.prototype.onMouseMove = function (x, y) {
        _super.prototype.onMouseMove.call(this, x, y);
        this.layer.y = y + this.touchPointY;
        this.checkConstrains();
        this.slidePositions.push({ liveTime: this.liveTime, y: y });
        if (this.slidePositions.length > 100) {
            this.calcSpeedCache = this.calcYSpeed();
            this.slidePositions.length = 0;
        }
    };
    SelectLevelState.prototype.checkConstrains = function () {
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        if (this.layer.y > -diff) {
            this.layer.y = -diff;
            this.ySpeed = 0;
        }
        if (Constants.g_isPC) {
            if (this.layer.y < Constants.ASSETS_HEIGHT - this.mapH) {
                this.layer.y = Constants.ASSETS_HEIGHT - this.mapH;
                this.ySpeed = 0;
            }
        }
        else {
            if (this.layer.y < Constants.SCREEN_HEIGHT - this.mapH - diff) {
                this.layer.y = Constants.SCREEN_HEIGHT - this.mapH - diff;
                this.ySpeed = 0;
            }
        }
    };
    SelectLevelState.prototype.onMouseUp = function (x, y) {
        _super.prototype.onMouseUp.call(this, x, y);
        this.slidePositions.push({ liveTime: this.liveTime, y: y });
        this.ySpeed = this.calcYSpeed();
    };
    SelectLevelState.prototype.calcYSpeed = function () {
        if (this.slidePositions.length < 2) {
            return this.calcSpeedCache;
        }
        var slide_time = 0.2;
        var i;
        for (i = this.slidePositions.length - 2; i > 0; --i) {
            if (this.liveTime - this.slidePositions[i]["liveTime"] >= slide_time) {
                break;
            }
        }
        var delay = this.liveTime - this.slidePositions[i]["liveTime"];
        if (delay < 0.00001) {
            return 0;
        }
        return (this.slidePositions[this.slidePositions.length - 1]["y"] - this.slidePositions[i]["y"]) / delay;
    };
    return SelectLevelState;
}(GameState));
/// <reference path="references.ts" />
var LevelDef = (function () {
    function LevelDef() {
    }
    return LevelDef;
}());
/// <reference path="references.ts" />
var HeartParticle = (function (_super) {
    __extends(HeartParticle, _super);
    function HeartParticle(speed_x, speed_y) {
        var _this = _super.call(this) || this;
        _this.rotSpeed = Utils.RandomRange(-120, 120);
        _this.speedX = speed_x;
        _this.speedY = speed_y;
        //this.addChild(AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_HEART_PARTICLE));
        var pic = AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_FLASH);
        pic.scaleX = pic.scaleY = 0.4;
        _this.addChild(pic);
        _this.alpha = 0;
        return _this;
    }
    HeartParticle.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        this.rotation += this.rotSpeed * dt;
        this.x += this.speedX * dt;
        this.y += this.speedY * dt;
        if (this.liveTime > 0.3) {
            this.alpha -= dt * 3;
            if (this.alpha <= 0) {
                this.kill();
            }
        }
        else {
            this.alpha += dt * 4;
        }
    };
    return HeartParticle;
}(GameObject));
/// <reference path="viewporter.d.ts" />
/// <reference path="createjs/createjs.d.ts" />
/// <reference path="createjs/easeljs.d.ts" />
/// <reference path="createjs/preloadjs.d.ts" />
/// <reference path="createjs/tweenjs.d.ts" />
/// <reference path="createjs/soundjs.d.ts" />
/// <reference path="StringManager.ts" />
/// <reference path="SoundManager.ts" />
/// <reference path="StateManager.ts" />
/// <reference path="GameState.ts" />
/// <reference path="Constants.ts" />
/// <reference path="AssetsManager.ts" />
/// <reference path="GameObject.ts" />
/// <reference path="Chip.ts" />
/// <reference path="Utils.ts" />
/// <reference path="AchievementsState.ts" />
/// <reference path="GameOverState.ts" />
/// <reference path="MainMenuState.ts" />
/// <reference path="ShadeInState.ts" />
/// <reference path="ShadeOutState.ts" />
/// <reference path="CreditsState.ts" />
/// <reference path="GameData.ts" />
/// <reference path="app.ts" />
/// <reference path="GUIObject.ts" />
/// <reference path="DNTextField.ts" />
/// <reference path="FlyingPoints.ts" />
/// <reference path="ConvertToBonusEffect.ts" />
/// <reference path="KillLineEffect.ts" />
/// <reference path="KillColorEffect.ts" />
/// <reference path="TimeIsUpEffect.ts" />
/// <reference path="MoveHint.ts" />
/// <reference path="TutorialHighlighter.ts" />
/// <reference path="Tutorial.ts" />
/// <reference path="PortraitLockState.ts" />
/// <reference path="SelectLevelState.ts" />
/// <reference path="LevelDef.ts" />
/// <reference path="HeartParticle.ts" />
/// <reference path="references.ts" />
var AutoreleaseEffect = (function (_super) {
    __extends(AutoreleaseEffect, _super);
    function AutoreleaseEffect(name, count, frame_time, loop, random_frame) {
        var _this = _super.call(this) || this;
        _this.frames = new Array();
        _this.frame = -1;
        _this.loop = false;
        _this.frameTime = frame_time;
        for (var i = 0; i < count; i++) {
            _this.frames.push(AssetsManager.g_instance.getCenteredImageWithProxy(name + i));
        }
        if (loop) {
            _this.loop = loop;
        }
        if (random_frame) {
            _this.frame = Utils.RandomRangeInt(0, _this.frames.length - 1);
        }
        _this.update(100);
        return _this;
    }
    AutoreleaseEffect.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        if (this.liveTime > this.frameTime) {
            this.liveTime = 0;
            this.frame++;
            if (this.frame >= this.frames.length) {
                this.frame = this.frames.length - 1;
                if (this.loop) {
                    this.frame = 0;
                }
                else {
                    this.kill();
                }
            }
            this.removeAllChildren();
            var pic = this.frames[this.frame];
            this.addChild(pic);
        }
    };
    return AutoreleaseEffect;
}(GameObject));
/// <reference path="references.ts" />
var CharDesc = (function () {
    function CharDesc() {
    }
    return CharDesc;
}());
;
var BitmapFont = (function () {
    function BitmapFont() {
    }
    return BitmapFont;
}());
var Fonts = (function () {
    function Fonts() {
    }
    return Fonts;
}());
Fonts.font_digits = {
    name: "digits_font_",
    height: 45,
    additionalXOffset: 3,
    charSet: {
        "+": { offset_x: -5, offset_y: 15, width: 19 },
        "0": { offset_x: -5, offset_y: 5, width: 28 },
        "1": { offset_x: -4, offset_y: 6, width: 14 },
        "2": { offset_x: -8, offset_y: 6, width: 23 },
        "3": { offset_x: -6, offset_y: 5, width: 24 },
        "4": { offset_x: -9, offset_y: 6, width: 26 },
        "5": { offset_x: -4, offset_y: 6, width: 26 },
        "6": { offset_x: -5, offset_y: 4, width: 26 },
        "7": { offset_x: -6, offset_y: 6, width: 23 },
        "8": { offset_x: -5, offset_y: 5, width: 25 },
        "9": { offset_x: -5, offset_y: 4, width: 26 }
    }
};
/// <reference path="references.ts" />
var DN_TEXT_ALIGN_HOR;
(function (DN_TEXT_ALIGN_HOR) {
    DN_TEXT_ALIGN_HOR[DN_TEXT_ALIGN_HOR["LEFT"] = 0] = "LEFT";
    DN_TEXT_ALIGN_HOR[DN_TEXT_ALIGN_HOR["RIGHT"] = 1] = "RIGHT";
    DN_TEXT_ALIGN_HOR[DN_TEXT_ALIGN_HOR["CENTER"] = 2] = "CENTER";
})(DN_TEXT_ALIGN_HOR || (DN_TEXT_ALIGN_HOR = {}));
;
var DN_TEXT_ALIGN_VERT;
(function (DN_TEXT_ALIGN_VERT) {
    DN_TEXT_ALIGN_VERT[DN_TEXT_ALIGN_VERT["TOP"] = 0] = "TOP";
    DN_TEXT_ALIGN_VERT[DN_TEXT_ALIGN_VERT["MIDDLE"] = 1] = "MIDDLE";
    DN_TEXT_ALIGN_VERT[DN_TEXT_ALIGN_VERT["BOTTOM"] = 2] = "BOTTOM";
})(DN_TEXT_ALIGN_VERT || (DN_TEXT_ALIGN_VERT = {}));
;
var BitmapLabel = (function (_super) {
    __extends(BitmapLabel, _super);
    function BitmapLabel(text, align_h, max_width, max_scale) {
        var _this = _super.call(this) || this;
        _this.maxW = 0;
        _this.alignH = DN_TEXT_ALIGN_HOR.CENTER;
        _this.alignW = DN_TEXT_ALIGN_VERT.TOP;
        _this.pic = new createjs.Text();
        _this.symbols = [];
        _this.maxScale = 1000;
        if (align_h != undefined) {
            _this.alignH = align_h;
        }
        _this.maxW = max_width || 0;
        _this.font = "40px Mail Ray Stuff";
        _this.maxScale = max_scale || 1000;
        _this.addChild(_this.pic);
        if (text) {
            _this.setText(text);
        }
        return _this;
    }
    BitmapLabel.prototype.setText = function (text) {
        this.text = text;
        this.pic.text = "";
        this.pic = new createjs.Text(text, this.font, "#8e4d11");
        this.pic.y = 10;
        this.addChild(this.pic);
        this.calcScale();
        this.calcAlign();
    };
    BitmapLabel.prototype.setMinScale = function (min_scale) {
        this.pic.scaleX = this.pic.scaleY = min_scale;
        this.calcAlign();
    };
    BitmapLabel.prototype.calcScale = function () {
        var scale = 1;
        if (this.maxW != 0) {
            if (this.pic.getBounds() == null) {
                return;
            }
            if (this.pic.getBounds().width > this.maxW) {
                scale = this.maxW / this.pic.getBounds().width;
            }
        }
        this.pic.scaleX = this.pic.scaleY = Math.min(scale, this.maxScale);
    };
    BitmapLabel.prototype.calcAlign = function () {
        if (!this.getBounds()) {
            console.log("text error");
            return;
        }
        switch (this.alignH) {
            case DN_TEXT_ALIGN_HOR.CENTER:
                this.pic.x = -this.pic.getBounds().width * 0.5 * this.pic.scaleX;
                if (this.debugShape) {
                    this.debugShape.x = -this.maxW / 2;
                }
                break;
            case DN_TEXT_ALIGN_HOR.LEFT:
                this.pic.x = 0;
                if (this.debugShape) {
                    this.debugShape.x = 0;
                }
                break;
            case DN_TEXT_ALIGN_HOR.RIGHT:
                this.pic.x = -this.pic.getBounds().width * this.pic.scaleX;
                if (this.debugShape) {
                    this.debugShape.x = -this.maxW;
                }
                break;
        }
    };
    BitmapLabel.prototype.getText = function () {
        return this.text;
    };
    return BitmapLabel;
}(GUIObject));
/// <reference path="references.ts" />
var BitmapLabelPoints = (function (_super) {
    __extends(BitmapLabelPoints, _super);
    function BitmapLabelPoints(bitmap_font, text, align_h, max_width, max_scale) {
        var _this = _super.call(this) || this;
        _this.maxW = 0;
        _this.alignH = DN_TEXT_ALIGN_HOR.CENTER;
        _this.alignW = DN_TEXT_ALIGN_VERT.TOP;
        _this.pic = new createjs.Container();
        _this.symbols = [];
        _this.maxScale = 1000;
        if (align_h != undefined) {
            _this.alignH = align_h;
        }
        _this.maxW = max_width || 0;
        _this.font = bitmap_font;
        _this.maxScale = max_scale || 1000;
        _this.addChild(_this.pic);
        if (text) {
            _this.setText(text);
        }
        return _this;
    }
    BitmapLabelPoints.prototype.setFont = function (font) {
        this.font = font;
    };
    BitmapLabelPoints.prototype.setText = function (text) {
        this.text = text;
        this.pic.removeAllChildren();
        this.symbols = [];
        var x_offset = 0;
        for (var i = 0; i < text.length; i++) {
            var char_code = text.charAt(i);
            var ch = new createjs.Container();
            var ch_pic = AssetsManager.g_instance.getImage(this.font.name + char_code);
            if (!ch_pic.getBounds()) {
                console.log("Error. Cant find char in font", this.font.name, char_code);
                continue;
            }
            if (!this.font.charSet[char_code]) {
                console.log("Error. No description data for char:", char_code);
                continue;
            }
            ch.addChild(ch_pic);
            this.pic.addChild(ch);
            ch.x = x_offset;
            ch.x += this.font.charSet[char_code]["offset_x"];
            ch.y += this.font.charSet[char_code]["offset_y"];
            x_offset += this.font.charSet[char_code]["width"] + this.font.additionalXOffset;
            this.symbols.push(ch);
        }
        this.calcScale();
        this.calcAlign();
    };
    BitmapLabelPoints.prototype.setMinScale = function (min_scale) {
        this.pic.scaleX = this.pic.scaleY = min_scale;
        this.calcAlign();
    };
    BitmapLabelPoints.prototype.calcScale = function () {
        var scale = 1;
        if (this.maxW != 0) {
            if (this.pic.getBounds() == null) {
                return;
            }
            if (this.pic.getBounds().width > this.maxW) {
                scale = this.maxW / this.pic.getBounds().width;
            }
        }
        this.pic.scaleX = this.pic.scaleY = Math.min(scale, this.maxScale);
    };
    BitmapLabelPoints.prototype.calcAlign = function () {
        if (!this.getBounds()) {
            console.log("text error");
            return;
        }
        switch (this.alignH) {
            case DN_TEXT_ALIGN_HOR.CENTER:
                this.pic.x = -this.pic.getBounds().width * 0.5 * this.pic.scaleX;
                if (this.debugShape) {
                    this.debugShape.x = -this.maxW / 2;
                }
                break;
            case DN_TEXT_ALIGN_HOR.LEFT:
                this.pic.x = 0;
                if (this.debugShape) {
                    this.debugShape.x = 0;
                }
                break;
            case DN_TEXT_ALIGN_HOR.RIGHT:
                this.pic.x = -this.pic.getBounds().width * this.pic.scaleX;
                if (this.debugShape) {
                    this.debugShape.x = -this.maxW;
                }
                break;
        }
    };
    BitmapLabelPoints.prototype.getText = function () {
        return this.text;
    };
    return BitmapLabelPoints;
}(GUIObject));
/// <reference path="references.ts" />
var ChainEffect = (function (_super) {
    __extends(ChainEffect, _super);
    function ChainEffect(from_x, from_y, to_x, to_y, chip) {
        var _this = _super.call(this) || this;
        _this.effect = new AutoreleaseEffect("chain_", 6, 0.06, true);
        _this.maxTime = 3.0;
        _this.chip = chip;
        _this.fromX = from_x;
        _this.fromY = from_y;
        _this.toX = to_x;
        _this.toY = to_y;
        _this.addChild(_this.effect);
        //this.addChild(AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_BONUS_BOMB));
        var len = Math.sqrt((from_x - to_x) * (from_x - to_x) + (from_y - to_y) * (from_y - to_y));
        _this.effect.x = (to_x + from_x) / 2;
        _this.effect.y = (to_y + from_y) / 2;
        _this.effect.scaleY = 0;
        //this.effect.scaleY = len / this.effect.getBounds().height;
        var rotation = -Math.atan2(to_x - from_x, to_y - from_y);
        _this.effect.rotation = Utils.RadToGrad(rotation);
        return _this;
    }
    ChainEffect.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        this.effect.update(dt);
        var progress = this.liveTime / this.maxTime;
        if (progress >= 1) {
            this.kill();
        }
        if (progress < 0.5) {
            this.effect.scaleY = progress;
            1;
        }
        this.effect.x = this.fromX + (this.toX - this.fromX) * progress;
        this.effect.y = this.fromY + (this.toY - this.fromY) * progress;
        //this.effect.y = this.fromY;
    };
    return ChainEffect;
}(GameObject));
/// <reference path="references.ts" />
var DNButton = (function (_super) {
    __extends(DNButton, _super);
    function DNButton(name, callback) {
        var _this = _super.call(this) || this;
        _this.selected = false;
        _this.func = null;
        _this.enabled = true;
        _this.picture = AssetsManager.g_instance.getCenteredImageWithProxy(name);
        _this.addChild(_this.picture);
        _this.func = callback;
        _this.picWidth = _this.picture.getBounds().width * 1.15;
        _this.picHeight = _this.picture.getBounds().height * 1.15;
        return _this;
    }
    DNButton.prototype.getPicture = function () {
        return this.picture;
    };
    DNButton.prototype.setPicture = function (pic) {
        this.removeChild(this.picture);
        this.picture = AssetsManager.g_instance.getCenteredImageWithProxy(pic);
        this.addChild(this.picture);
    };
    DNButton.prototype.setHandler = function (callback) {
        this.func = callback;
    };
    DNButton.prototype.select = function () {
        if (!this.selected) {
            createjs.Tween.removeTweens(this.picture);
            createjs.Tween.get(this.picture).to({ scaleX: 1.15, scaleY: 1.15 }, 100, createjs.Ease.linear);
            this.selected = true;
        }
    };
    DNButton.prototype.deselect = function () {
        if (this.selected) {
            createjs.Tween.removeTweens(this.picture);
            createjs.Tween.get(this.picture).to({ scaleX: 1.0, scaleY: 1.0 }, 100, createjs.Ease.linear);
            this.selected = false;
        }
    };
    DNButton.prototype.onMouseDown = function (x, y) {
        if (this.hitTestSmart(x, y)) {
            this.liveTime = 0;
            this.select();
        }
    };
    DNButton.prototype.onMouseUp = function (x, y) {
        if (this.hitTestSmart(x, y) && this.selected) {
            if (!GUIObject.wasHandlerThisFrame) {
                GUIObject.wasHandlerThisFrame = true;
                this.func();
                //  run action
                SoundManager.g_instance.play(SoundManager.SOUND_CLICK);
            }
        }
        this.deselect();
    };
    DNButton.prototype.onMouseMove = function (x, y) {
        if (!this.hitTestSmart(x, y)) {
            this.deselect();
        }
    };
    DNButton.prototype.hitTestSmart = function (x, y) {
        if (!this.enabled) {
            return;
        }
        if (!this.parent || !this.visible) {
            return false;
        }
        var pos = this.picture.localToGlobal(0, 0);
        pos.x /= Constants.SCREEN_SCALE;
        pos.y /= Constants.SCREEN_SCALE;
        var w = this.picture.getBounds().width * 0.4 * this.scaleX;
        var h = this.picture.getBounds().height * 0.4 * this.scaleY;
        return pos.x < x + w && pos.x > x - w && pos.y < y + h && pos.y > y - h;
    };
    DNButton.prototype.setEnabled = function (enabled) {
        this.enabled = enabled;
    };
    return DNButton;
}(GUIObject));
/// <reference path="references.ts" />
var DNTimer = (function (_super) {
    __extends(DNTimer, _super);
    function DNTimer(time, count, action) {
        var _this = _super.call(this) || this;
        _this.count = 1000000;
        _this.loop = false;
        _this.time = time;
        _this.count = count;
        _this.action = action;
        if (!_this.count) {
            _this.loop = true;
        }
        return _this;
    }
    DNTimer.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        if (this.liveTime > this.time) {
            this.runAction();
            this.liveTime -= this.time;
            if (!this.loop) {
                this.count--;
                if (this.count <= 0) {
                    this.kill();
                }
            }
        }
    };
    DNTimer.prototype.runAction = function () {
        if (this.action) {
            this.action();
        }
    };
    return DNTimer;
}(GameObject));
/// <reference path="references.ts" />
var FallingTrash = (function (_super) {
    __extends(FallingTrash, _super);
    //private speedY: number = -600;
    function FallingTrash(name) {
        var _this = _super.call(this) || this;
        _this.rotationSpeed = Utils.RandomRange(-300, 300);
        _this.speedX = Utils.RandomRange(-300, +300);
        _this.speedY = Utils.RandomRange(-600, -300);
        _this.addChild(AssetsManager.g_instance.getCenteredImageWithProxy(name));
        return _this;
    }
    FallingTrash.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        this.rotation += dt * this.rotationSpeed;
        this.speedY += dt * Constants.GRAVITY_ACC;
        this.x += this.speedX * dt;
        this.y += this.speedY * dt;
        if (this.liveTime > 0.3) {
            this.alpha -= dt * 3;
            if (this.alpha <= 0) {
                this.kill();
            }
        }
        if (this.y >= 900) {
            this.kill;
        }
    };
    return FallingTrash;
}(GameObject));
/// <reference path="references.ts" />
var GameObjectAdder = (function (_super) {
    __extends(GameObjectAdder, _super);
    function GameObjectAdder(game_object, delay, state, layer) {
        var _this = _super.call(this) || this;
        _this.delay = delay;
        _this.gameObject = game_object;
        _this.state = state;
        _this.layer = layer;
        return _this;
    }
    GameObjectAdder.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        if (this.liveTime > this.delay) {
            this.state.addGameObjectAt(this.gameObject, this.layer);
            this.kill();
        }
    };
    return GameObjectAdder;
}(GameObject));
/// <reference path="references.ts" />
var GradientInState = (function (_super) {
    __extends(GradientInState, _super);
    function GradientInState(next_state) {
        var _this = _super.call(this) || this;
        _this.shader = new createjs.Container();
        _this.addChild(_this.shader);
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        var gradient_left = AssetsManager.g_instance.getImage(Constants.IMAGE_GRADIENT);
        _this.shader.addChild(gradient_left);
        gradient_left.y -= diff;
        gradient_left.x = Constants.ASSETS_WIDTH + 2;
        gradient_left.scaleY = (Constants.SCREEN_HEIGHT + diff + 200) / gradient_left.getBounds().height;
        var black_square = AssetsManager.g_instance.getImage(Constants.IMAGE_BLACK_SQUARE);
        black_square.scaleX = Constants.ASSETS_WIDTH / black_square.getBounds().width;
        black_square.scaleY = (Constants.SCREEN_HEIGHT + diff + 200) / black_square.getBounds().height;
        _this.shader.addChild(black_square);
        black_square.x = Constants.ASSETS_WIDTH + gradient_left.getBounds().width;
        black_square.y -= diff;
        _this.nextState = next_state;
        return _this;
    }
    GradientInState.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        this.shader.x += -1 / Constants.GRADIENT_TRANSITION_TIME * Constants.ASSETS_WIDTH * dt;
        if (this.shader.x <= -Constants.ASSETS_WIDTH - 256) {
            StateManager.g_instance.changeState(this.nextState);
            StateManager.g_instance.pushState(new GradientOutState());
        }
    };
    return GradientInState;
}(GameState));
/// <reference path="references.ts" />
var GradientOutState = (function (_super) {
    __extends(GradientOutState, _super);
    function GradientOutState() {
        var _this = _super.call(this) || this;
        _this.shader = new createjs.Container();
        _this.addChild(_this.shader);
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        var black_square = AssetsManager.g_instance.getImage(Constants.IMAGE_BLACK_SQUARE);
        black_square.scaleX = Constants.ASSETS_WIDTH / black_square.getBounds().width;
        black_square.scaleY = (Constants.SCREEN_HEIGHT + diff + 200) / black_square.getBounds().height;
        black_square.y -= diff;
        _this.shader.addChild(black_square);
        var gradient_right = AssetsManager.g_instance.getImage(Constants.IMAGE_GRADIENT);
        gradient_right.scaleX = -1;
        gradient_right.scaleY = (Constants.SCREEN_HEIGHT + diff + 200) / gradient_right.getBounds().height;
        _this.shader.addChild(gradient_right);
        gradient_right.x = Constants.ASSETS_WIDTH + gradient_right.getBounds().width - 2;
        gradient_right.y -= diff;
        return _this;
    }
    GradientOutState.prototype.update = function (dt) {
        this.shader.x -= 1 / Constants.GRADIENT_TRANSITION_TIME * Constants.ASSETS_WIDTH * dt;
        if (this.shader.x <= -Constants.ASSETS_WIDTH - 256) {
            StateManager.g_instance.popState();
        }
    };
    return GradientOutState;
}(GameState));
var GratzState = (function (_super) {
    __extends(GratzState, _super);
    function GratzState() {
        var _this = _super.call(this) || this;
        _this.panel = new createjs.Container();
        _this.hiddingNow = false;
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        //  shading
        _this.shader = new createjs.Shape();
        _this.shader.graphics.beginFill("#000000");
        _this.shader.graphics.drawRect(0, -diff, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT + diff);
        _this.shader.graphics.endFill();
        _this.addChild(_this.shader);
        _this.shader.alpha = 0;
        createjs.Tween.get(_this.shader, { loop: false }).wait(300).to({ alpha: 0.4 }, 800, createjs.Ease.linear);
        _this.addChild(_this.panel);
        _this.panel.x = Constants.ASSETS_WIDTH / 2;
        _this.panel.y = Constants.SCREEN_HEIGHT * 0.5;
        var panel = AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_MESSAGE_WINDOW);
        _this.panel.addChild(panel);
        var button_ok = new DNButton(Constants.IMAGE_BUTTON_PLAY, function () { return _this.hide(); });
        _this.panel.addChild(button_ok);
        _this.addGuiObject(button_ok);
        button_ok.x = 0;
        button_ok.y = 100;
        var pause_panel = AssetsManager.g_instance.getCenteredImageWithProxy("pause_panel");
        pause_panel.y = -80;
        pause_panel.scaleY = 1.5;
        _this.panel.addChild(pause_panel);
        var pause_text = new TextBoxWebFont(StringManager.getInstance().getString(StringManager.GJ_MESSAGE), 500, 150);
        pause_text.y = -120;
        pause_text.x = 0;
        _this.panel.addChild(pause_text);
        _this.panel.alpha = 0.0;
        createjs.Tween.get(_this.panel, { loop: false }).to({ alpha: 1 }, 200, createjs.Ease.linear);
        _this.panel.y -= diff;
        _this.panel.scaleX = 0.7;
        _this.panel.scaleY = 0.7;
        createjs.Tween.get(_this.panel, { loop: false }).to({ scaleX: 1, scaleY: 1 }, 400, createjs.Ease.backOut);
        return _this;
    }
    GratzState.prototype.hide = function () {
        if (!this.hiddingNow) {
            createjs.Tween.removeTweens(this.panel);
            createjs.Tween.removeTweens(this.shader);
            createjs.Tween.get(this.panel, { loop: false }).to({ alpha: 0 }, 200, createjs.Ease.linear);
            createjs.Tween.get(this.panel, { loop: false }).to({ scaleX: 0.7, scaleY: 0.7 }, 400, createjs.Ease.backOut)
                .call(function () { StateManager.g_instance.popState(); });
            createjs.Tween.get(this.shader, { loop: false }).to({ alpha: 0.0 }, 400, createjs.Ease.linear);
            this.hiddingNow = true;
        }
    };
    GratzState.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
    };
    return GratzState;
}(GameState));
/// <reference path="references.ts" />
var LevelCreatorChip = (function (_super) {
    __extends(LevelCreatorChip, _super);
    function LevelCreatorChip(id, x_index, y_index) {
        var _this = _super.call(this) || this;
        _this.selected = false;
        _this.cage = null;
        _this.hole = false;
        _this.stoneHeart = false;
        //  hz
        _this.obtacle = false;
        _this.obtaclePower = 2;
        _this.setIncexes(x_index, y_index);
        if (id != 9 && id != 0 && id != 8) {
            _this.chipPicture = AssetsManager.g_instance.getCenteredImageWithProxy("cake_" + id);
            _this.addChild(_this.chipPicture);
        }
        _this.colorID = id;
        if (id == 8) {
            _this.convertToObtacle(2);
        }
        if (id == 9) {
            _this.convertToStoneHeart();
        }
        return _this;
    }
    LevelCreatorChip.prototype.setCage = function () {
        this.cage = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_CAGE);
        this.addChild(this.cage);
    };
    LevelCreatorChip.prototype.haveCage = function () {
        return this.cage != null;
    };
    LevelCreatorChip.prototype.removeCage = function () {
        if (this.haveCage()) {
            this.removeChild(this.cage);
            this.cage = null;
        }
    };
    LevelCreatorChip.prototype.dropFlags = function () {
        this.stoneHeart = false;
        this.hole = false;
        this.obtacle = false;
    };
    LevelCreatorChip.prototype.nextID = function () {
        this.dropFlags();
        this.removeAllChildren();
        if (this.colorID == -1) {
            this.dropFlags();
            this.colorID = 0;
        }
        this.colorID++;
        if (this.colorID >= 8) {
            this.colorID = 1;
        }
        this.chipPicture = AssetsManager.g_instance.getCenteredImageWithProxy("cake_" + this.colorID);
        this.addChild(this.chipPicture);
        if (this.haveCage()) {
            this.setCage();
        }
    };
    LevelCreatorChip.prototype.getColorID = function () {
        return this.colorID;
    };
    LevelCreatorChip.prototype.getIndeces = function () {
        return new createjs.Point(this.indexX, this.indexY);
    };
    LevelCreatorChip.prototype.getIndexX = function () {
        return this.indexX;
    };
    LevelCreatorChip.prototype.getIndexY = function () {
        return this.indexY;
    };
    LevelCreatorChip.prototype.setIncexes = function (x, y) {
        this.indexX = x;
        this.indexY = y;
    };
    LevelCreatorChip.prototype.isHole = function () {
        return this.hole;
    };
    LevelCreatorChip.prototype.convertToHole = function () {
        this.dropFlags();
        this.removeAllChildren();
        this.hole = true;
        this.colorID = -1;
        this.chipPicture = AssetsManager.g_instance.getCenteredImageWithProxy(Math.random() < 0.5 ? Constants.IMAGE_BUSH_1 : Constants.IMAGE_BUSH_2);
        this.addChild(this.chipPicture);
    };
    LevelCreatorChip.prototype.convertHoleToChip = function () {
        this.dropFlags();
        this.removeAllChildren();
        this.colorID = 2;
        this.chipPicture = AssetsManager.g_instance.getImage("cake_" + this.colorID);
        this.addChild(this.chipPicture);
        this.chipPicture.x = -this.chipPicture.getBounds().width / 2;
        this.chipPicture.y = -Constants.CELL_SIZE / 2;
    };
    LevelCreatorChip.prototype.convertToStoneHeart = function () {
        this.dropFlags();
        this.removeAllChildren();
        this.stoneHeart = true;
        this.colorID = -1;
        this.chipPicture = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_STONE_HEART);
        this.addChild(this.chipPicture);
    };
    LevelCreatorChip.prototype.isStoneHeart = function () {
        return this.stoneHeart;
    };
    LevelCreatorChip.prototype.getObstaclePower = function () {
        return this.obtaclePower;
    };
    LevelCreatorChip.prototype.convertToObtacle = function (power) {
        this.dropFlags();
        this.removeAllChildren();
        this.obtacle = true;
        this.colorID = -1;
        this.obtaclePower = power;
        this.chipPicture = AssetsManager.g_instance.getCenteredImageWithProxy("obtacle_" + power);
        this.addChild(this.chipPicture);
    };
    LevelCreatorChip.prototype.isObtacle = function () {
        return this.obtacle;
    };
    return LevelCreatorChip;
}(GameObject));
LevelCreatorChip.BONUS_CROSS = "BONUS_CROSS";
LevelCreatorChip.BONUS_COLOR = "BONUS_COLOR";
LevelCreatorChip.BONUS_BOMB = "BONUS_BOMB";
LevelCreatorChip.BONUS_SHAMAN = "BONUS_SHAMAN";
/// <reference path="references.ts" />
var LevelCreatorState = (function (_super) {
    __extends(LevelCreatorState, _super);
    function LevelCreatorState() {
        var _this = _super.call(this) || this;
        _this.inputMode = "INPUT_MODE_CHIPS";
        _this.goal = LevelCreatorState.GOAL_DIRT;
        _this.goalLabel = new DNTextField("0", "font_", -3);
        _this.dirtCount = 0;
        _this.fieldWidth = 8;
        _this.fieldHeight = 8;
        _this.selectedChip = null;
        _this.dirtLayer = new createjs.Container();
        _this.underChipsLayer = new createjs.Container();
        _this.backChipsLayer = new createjs.Container();
        _this.holeLayer = new createjs.Container();
        _this.edgesLayer = new createjs.Container();
        _this.frontChipsLayer = new createjs.Container();
        _this.moves = 30;
        _this.movesLabel = new DNTextField("50", "font_", -3);
        _this.chipTypes = new Array();
        _this.inputModesArr = [
            LevelCreatorState.INPUT_MODE_CHIPS,
            LevelCreatorState.INPUT_MODE_CAGE,
            LevelCreatorState.INPUT_MODE_DIRT,
            LevelCreatorState.INPUT_MODE_FORM,
            LevelCreatorState.INPUT_MODE_STONEHEART,
            LevelCreatorState.INPUT_MODE_OBSTACLE
        ];
        _this.goals = [
            LevelCreatorState.GOAL_COUNT,
            LevelCreatorState.GOAL_DIRT,
            LevelCreatorState.GOAL_SCORE,
            LevelCreatorState.GOAL_BONUS
        ];
        _this.buttonsChips = new Array();
        _this.bonusTypes = [
            LevelCreatorChip.BONUS_BOMB,
            LevelCreatorChip.BONUS_COLOR,
            LevelCreatorChip.BONUS_CROSS,
            LevelCreatorChip.BONUS_SHAMAN
        ];
        _this.bonusTypeIterator = 0;
        _this.inputIterator = 0;
        var back = AssetsManager.g_instance.getImage(Constants.IMAGE_BACK);
        _this.addChild(back);
        //  alloc
        _this.field = new Array(_this.fieldWidth);
        for (var i = 0; i < _this.fieldWidth; i++) {
            _this.field[i] = new Array(_this.fieldHeight);
        }
        _this.addChild(_this.dirtLayer);
        _this.addChild(_this.edgesLayer);
        _this.addChild(_this.underChipsLayer);
        _this.addChild(_this.backChipsLayer);
        _this.addChild(_this.holeLayer);
        _this.addChild(_this.frontChipsLayer);
        _this.spawnDefinedChips(GameData.getInstance().mapEditorLevel.chips);
        var form = GameData.getInstance().mapEditorLevel.form;
        for (var x = 0; x < _this.fieldWidth; x++) {
            for (var y = 0; y < _this.fieldHeight; y++) {
                if (form[y][x] == 0) {
                    _this.field[x][y].convertToHole();
                    _this.holeLayer.addChild(_this.field[x][y]);
                }
            }
        }
        //  alloc dirt
        _this.fieldDirt = new Array(_this.fieldWidth);
        for (var i = 0; i < _this.fieldWidth; i++) {
            _this.fieldDirt[i] = new Array(_this.fieldHeight);
        }
        //  init dirt
        var dirt_template = GameData.getInstance().mapEditorLevel.dirt;
        if (dirt_template) {
            for (var x = 0; x < _this.fieldWidth; x++) {
                for (var y = 0; y < _this.fieldHeight; y++) {
                    if (dirt_template[y][x] != 0) {
                        _this.dirtCount++;
                        var dirt = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_DIRT);
                        dirt.x = _this.getXPosByXIndex(x) - 1;
                        dirt.y = _this.getYPosByYIndex(y) + 3;
                        _this.dirtLayer.addChild(dirt);
                        _this.fieldDirt[x][y] = dirt;
                    }
                }
            }
            _this.goalLabel.setText(_this.dirtCount.toString());
        }
        if (GameData.getInstance().mapEditorLevel.goal_type == LevelCreatorState.GOAL_COUNT) {
            _this.goal = LevelCreatorState.GOAL_COUNT;
            _this.goalChipID = GameData.getInstance().mapEditorLevel.chip_goal;
            _this.chipGoalCount = GameData.getInstance().mapEditorLevel.chip_goal_count;
            _this.goalLabel.setText(_this.chipGoalCount.toString());
        }
        if (!_this.goalChipID) {
            _this.goalChipID = 1;
        }
        //---------- gui overlaps
        var gui = AssetsManager.g_instance.getImage(Constants.IMAGE_GUI);
        gui.y -= 150;
        _this.addChild(gui);
        var play_proxy = new createjs.Container();
        //pause_proxy.scaleX = pause_proxy.scaleY = 0.9;
        var button_play = new DNButton(Constants.IMAGE_BUTTON_PLAY, function () { return _this.onPlayClick(); });
        play_proxy.addChild(button_play);
        _this.addGuiObject(button_play);
        play_proxy.x = 80;
        play_proxy.y = 85;
        button_play.scaleX = button_play.scaleY = 0.6;
        _this.addChild(play_proxy);
        var change_proxy = new createjs.Container();
        var button_change_input = new DNButton(Constants.IMAGE_FIRST_LEVEL_HINT, function () { return _this.onChangeInputClick(); });
        change_proxy.addChild(button_change_input);
        _this.addGuiObject(button_change_input);
        change_proxy.x = 200;
        change_proxy.y = 865;
        _this.addChild(change_proxy);
        var state_proxy = new createjs.Container();
        _this.stateText = new BitmapLabel(_this.inputMode);
        state_proxy.addChild(_this.stateText);
        state_proxy.x = 450;
        state_proxy.y = 830;
        _this.addGuiObject(_this.stateText);
        _this.addChild(state_proxy);
        _this.moves = GameData.getInstance().mapEditorLevel.moves;
        _this.addChild(_this.movesLabel);
        _this.movesLabel.x = 250;
        _this.movesLabel.y = 80;
        _this.movesLabel.setText(_this.moves.toString());
        //  ???
        _this.addChild(_this.goalLabel);
        _this.goalLabel.x = 560;
        _this.goalLabel.y = 53;
        _this.chipTypes = GameData.getInstance().mapEditorLevel.chip_types.length != 0 ?
            GameData.getInstance().mapEditorLevel.chip_types :
            _this.collectColorsOnField();
        var _loop_1 = function (i_1) {
            var k = i_1;
            var button_cake = new DNButton("cake_" + i_1, function () { return _this.onChipClick(k - 1); });
            button_cake.x = 190 + i_1 * 30;
            button_cake.y = 40;
            button_cake.scaleX = button_cake.scaleY = 0.4;
            button_cake.alpha = this_1.chipTypes.indexOf(i_1) == -1 ? 0.4 : 1;
            this_1.addGuiObject(button_cake);
            this_1.addChild(button_cake);
            this_1.buttonsChips.push(button_cake);
        };
        var this_1 = this;
        for (var i_1 = 1; i_1 < 8; i_1++) {
            _loop_1(i_1);
        }
        _this.goal = GameData.getInstance().mapEditorLevel.goal_type;
        switch (_this.goal) {
            case LevelCreatorState.GOAL_BONUS:
                _this.showArrowsNearGoal();
                _this.showArrowsNearCountGoal();
                _this.bonusTypeIterator = _this.bonusTypes.indexOf(GameData.getInstance().mapEditorLevel.chip_goal_bonus);
                _this.goalPic = new DNButton(_this.getImageByBonusType(), function () { return _this.OnGoalClick(); });
                _this.addGuiObject(_this.goalPic);
                _this.goalPic.scaleX = _this.goalPic.scaleY = 0.66;
                _this.addChild(_this.goalPic);
                _this.goalPic.x = 516;
                _this.goalPic.y = 67;
                _this.chipGoalCount = GameData.getInstance().mapEditorLevel.chip_goal_count;
                _this.goalLabel.setText(_this.chipGoalCount.toString());
                break;
            case LevelCreatorState.GOAL_COUNT:
                _this.showArrowsNearGoal();
                _this.showArrowsNearCountGoal();
                _this.chipGoalCount = GameData.getInstance().mapEditorLevel.chip_goal_count;
                _this.goalLabel.setText(_this.chipGoalCount.toString());
                _this.goalPic = new DNButton("cake_" + _this.goalChipID, function () { return _this.OnGoalClick(); });
                _this.addGuiObject(_this.goalPic);
                _this.goalPic.scaleX = _this.goalPic.scaleY = 0.66;
                _this.addChild(_this.goalPic);
                _this.goalPic.x = 516;
                _this.goalPic.y = 67;
                break;
            case LevelCreatorState.GOAL_DIRT:
                _this.goalPic = new DNButton(Constants.IMAGE_DIRT, function () { return _this.OnGoalClick(); });
                _this.chipGoalCount = GameData.getInstance().mapEditorLevel.chip_goal_count;
                _this.goalLabel.setText(_this.chipGoalCount.toString());
                _this.addGuiObject(_this.goalPic);
                _this.goalPic.scaleX = _this.goalPic.scaleY = 0.66;
                _this.addChild(_this.goalPic);
                _this.goalPic.x = 516;
                _this.goalPic.y = 67;
                break;
            case LevelCreatorState.GOAL_SCORE:
                _this.goalPic = new DNButton("score_bonus", function () { return _this.OnGoalClick(); });
                _this.showArrowsNearCountGoal();
                _this.chipGoalCount = GameData.getInstance().mapEditorLevel.chip_goal_count;
                _this.goalLabel.setText(_this.chipGoalCount.toString());
                _this.addGuiObject(_this.goalPic);
                _this.goalPic.scaleX = _this.goalPic.scaleY = 0.66;
                _this.addChild(_this.goalPic);
                _this.goalPic.x = 516;
                _this.goalPic.y = 67;
                break;
        }
        _this.showArrowsNearCountGoal();
        _this.showArrowsNearMoves();
        _this.configureYAlign();
        return _this;
    }
    LevelCreatorState.prototype.onChipClick = function (chip_num) {
        if (this.collectColorsOnField().indexOf(chip_num + 1) != -1) {
            return;
        }
        if (this.buttonsChips[chip_num].alpha == 0.4) {
            this.buttonsChips[chip_num].alpha = 1;
            this.chipTypes.push(chip_num + 1);
        }
        else {
            this.buttonsChips[chip_num].alpha = 0.4;
            this.chipTypes.splice(this.chipTypes.indexOf(chip_num + 1), 1);
        }
    };
    LevelCreatorState.prototype.updateChipsButtons = function () {
        var chip_types = this.collectColorsOnField();
        for (var i = 0; i < this.buttonsChips.length; i++) {
            if (chip_types.indexOf(i + 1) != -1) {
                this.buttonsChips[i].alpha = 1;
                if (this.chipTypes.indexOf(i + 1) == -1) {
                    this.chipTypes.push(i + 1);
                }
            }
        }
    };
    LevelCreatorState.prototype.showArrowsNearGoal = function () {
        var _this = this;
        this.arrowsContainerGoal = new createjs.Container();
        var arrow_up = new DNButton(Constants.IMAGE_HINT_ARROW, function () { return _this.onGoalNext(); });
        arrow_up.scaleX = arrow_up.scaleY = 0.5;
        arrow_up.rotation = -90;
        this.addGuiObject(arrow_up);
        this.arrowsContainerGoal.addChild(arrow_up);
        arrow_up.y = -20;
        this.arrowsContainerGoal.x = 470;
        this.arrowsContainerGoal.y = 70;
        this.addChild(this.arrowsContainerGoal);
    };
    LevelCreatorState.prototype.OnMovesPlus = function () {
        this.moves++;
        this.movesLabel.setText(this.moves.toString());
    };
    LevelCreatorState.prototype.printLevelToConsole = function () {
        var level_def = GameData.getInstance().mapEditorLevel;
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                if (this.field[x][y].isHole()) {
                    level_def.chips[y][x] = 0;
                }
                else if (this.field[x][y].isObtacle()) {
                    level_def.chips[y][x] = 8;
                }
                else if (this.field[x][y].isStoneHeart()) {
                    level_def.chips[y][x] = 9;
                }
                else {
                    level_def.chips[y][x] = this.field[x][y].getColorID() + (this.field[x][y].haveCage() ? 10 : 0);
                }
            }
        }
        var have_dirt = false;
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                if (this.fieldDirt[x][y] != null) {
                    have_dirt = true;
                }
            }
        }
        if (have_dirt) {
            var dirt = new Array(this.fieldHeight);
            for (var i = 0; i < this.fieldHeight; i++) {
                dirt[i] = new Array(this.fieldWidth);
            }
            for (var x = 0; x < this.fieldWidth; x++) {
                for (var y = 0; y < this.fieldHeight; y++) {
                    dirt[y][x] = this.fieldDirt[x][y] != null ? 1 : 0;
                }
            }
            level_def.dirt = dirt;
        }
        else {
            level_def.dirt = null;
        }
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                level_def.form[y][x] = this.field[x][y].isHole() ? 0 : 1;
            }
        }
        level_def.moves = this.moves;
        level_def.goal_type = this.goal;
        level_def.chip_types = this.chipTypes;
        level_def.chip_goal_count = this.chipGoalCount;
        level_def.chip_goal = this.goalChipID;
        level_def.chip_goal_bonus = this.bonusTypes[this.bonusTypeIterator];
        console.log(JSON.stringify(level_def));
    };
    LevelCreatorState.prototype.OnMovesMinus = function () {
        this.moves--;
        if (this.moves < 0) {
            this.moves = 0;
        }
        this.movesLabel.setText(this.moves.toString());
    };
    LevelCreatorState.prototype.showArrowsNearCountGoal = function () {
        var _this = this;
        this.arrowsContainerCountGoal = new createjs.Container();
        var arrow_down = new DNButton(Constants.IMAGE_HINT_ARROW, function () { return _this.onGoalCountMinus(); });
        arrow_down.scaleX = arrow_down.scaleY = 0.5;
        arrow_down.rotation = 90;
        this.addGuiObject(arrow_down);
        this.arrowsContainerCountGoal.addChild(arrow_down);
        var arrow_up = new DNButton(Constants.IMAGE_HINT_ARROW, function () { return _this.onGoalCountPlus(); });
        arrow_up.scaleX = arrow_up.scaleY = 0.5;
        arrow_up.rotation = -90;
        this.addGuiObject(arrow_up);
        this.arrowsContainerCountGoal.addChild(arrow_up);
        arrow_up.y = -20;
        arrow_down.y = 20;
        this.arrowsContainerCountGoal.x = 670;
        this.arrowsContainerCountGoal.y = 70;
        this.addChild(this.arrowsContainerCountGoal);
    };
    LevelCreatorState.prototype.showArrowsNearMoves = function () {
        var _this = this;
        var arrowsContainerCountMoves = new createjs.Container();
        var arrow_down = new DNButton(Constants.IMAGE_HINT_ARROW, function () { return _this.OnMovesMinus(); });
        arrow_down.scaleX = arrow_down.scaleY = 0.5;
        arrow_down.rotation = 90;
        this.addGuiObject(arrow_down);
        arrowsContainerCountMoves.addChild(arrow_down);
        var arrow_up = new DNButton(Constants.IMAGE_HINT_ARROW, function () { return _this.OnMovesPlus(); });
        arrow_up.scaleX = arrow_up.scaleY = 0.5;
        arrow_up.rotation = -90;
        this.addGuiObject(arrow_up);
        arrowsContainerCountMoves.addChild(arrow_up);
        arrow_up.y = -20;
        arrow_down.y = 20;
        arrowsContainerCountMoves.x = 400;
        arrowsContainerCountMoves.y = 100;
        this.addChild(arrowsContainerCountMoves);
    };
    LevelCreatorState.prototype.OnGoalClick = function () {
        var index_goal = this.goals.indexOf(this.goal);
        index_goal = (index_goal + 1) % this.goals.length;
        //this.removeChild(this.goalPic);
        this.goal = this.goals[index_goal];
        this.HideArrowsGoal();
        this.HideArrowsCount();
        switch (this.goals[index_goal]) {
            case LevelCreatorState.GOAL_BONUS:
                this.showArrowsNearGoal();
                this.showArrowsNearCountGoal();
                this.goalPic.setPicture(this.getImageByBonusType());
                this.chipGoalCount = 10;
                this.goalLabel.setText(this.chipGoalCount.toString());
                break;
            case LevelCreatorState.GOAL_COUNT:
                this.showArrowsNearGoal();
                this.showArrowsNearCountGoal();
                this.chipGoalCount = 10;
                this.goalLabel.setText(this.chipGoalCount.toString());
                this.goalPic.setPicture("cake_" + this.goalChipID);
                break;
            case LevelCreatorState.GOAL_DIRT:
                this.goalPic.setPicture(Constants.IMAGE_DIRT);
                this.chipGoalCount = 10;
                this.goalLabel.setText(this.chipGoalCount.toString());
                break;
            case LevelCreatorState.GOAL_SCORE:
                this.goalPic.setPicture("score_bonus");
                this.showArrowsNearCountGoal();
                this.chipGoalCount = 250;
                this.goalLabel.setText(this.chipGoalCount.toString());
                break;
        }
    };
    LevelCreatorState.prototype.getImageByBonusType = function () {
        switch (this.bonusTypes[this.bonusTypeIterator]) {
            case LevelCreatorChip.BONUS_BOMB:
                return Constants.IMAGE_BONUS_BOMB;
            case LevelCreatorChip.BONUS_COLOR:
                return Constants.IMAGE_BONUS_COLOR;
            case LevelCreatorChip.BONUS_CROSS:
                return Constants.IMAGE_BONUS_CROSS_GUI;
            case LevelCreatorChip.BONUS_SHAMAN:
                return Constants.IMAGE_BONUS_SHAMAN;
        }
    };
    LevelCreatorState.prototype.onGoalNext = function () {
        switch (this.goal) {
            case LevelCreatorState.GOAL_BONUS:
                this.bonusTypeIterator = (this.bonusTypeIterator + 1) % this.bonusTypes.length;
                //this.removeChild(this.goalPic);
                switch (this.bonusTypes[this.bonusTypeIterator]) {
                    case LevelCreatorChip.BONUS_BOMB:
                        this.goalPic.setPicture(Constants.IMAGE_BONUS_BOMB);
                        break;
                    case LevelCreatorChip.BONUS_COLOR:
                        this.goalPic.setPicture(Constants.IMAGE_BONUS_COLOR);
                        break;
                    case LevelCreatorChip.BONUS_CROSS:
                        this.goalPic.setPicture(Constants.IMAGE_BONUS_CROSS_GUI);
                        break;
                    case LevelCreatorChip.BONUS_SHAMAN:
                        this.goalPic.setPicture(Constants.IMAGE_BONUS_SHAMAN);
                        break;
                }
                break;
            case LevelCreatorState.GOAL_COUNT:
                this.goalChipID = (this.goalChipID) % 7 + 1;
                //this.removeChild(this.goalPic);
                this.goalPic.setPicture("cake_" + this.goalChipID);
                break;
            default:
                break;
        }
    };
    LevelCreatorState.prototype.onGoalCountPlus = function () {
        switch (this.goal) {
            case LevelCreatorState.GOAL_BONUS:
                this.chipGoalCount++;
                this.goalLabel.setText(this.chipGoalCount.toString());
                break;
            case LevelCreatorState.GOAL_COUNT:
                this.chipGoalCount++;
                this.goalLabel.setText(this.chipGoalCount.toString());
                break;
            case LevelCreatorState.GOAL_SCORE:
                this.chipGoalCount += 250;
                this.goalLabel.setText(this.chipGoalCount.toString());
                break;
            case LevelCreatorState.GOAL_DIRT:
                this.chipGoalCount += 1;
                this.goalLabel.setText(this.chipGoalCount.toString());
                break;
            default:
                break;
        }
    };
    LevelCreatorState.prototype.onGoalCountMinus = function () {
        switch (this.goal) {
            case LevelCreatorState.GOAL_BONUS:
                this.chipGoalCount -= 1;
                if (this.chipGoalCount < 0) {
                    this.chipGoalCount = 0;
                }
                this.goalLabel.setText(this.chipGoalCount.toString());
                break;
            case LevelCreatorState.GOAL_COUNT:
                this.chipGoalCount -= 1;
                if (this.chipGoalCount < 0) {
                    this.chipGoalCount = 0;
                }
                this.goalLabel.setText(this.chipGoalCount.toString());
                break;
            case LevelCreatorState.GOAL_SCORE:
                this.chipGoalCount -= 250;
                if (this.chipGoalCount < 0) {
                    this.chipGoalCount = 0;
                }
                this.goalLabel.setText(this.chipGoalCount.toString());
                break;
            case LevelCreatorState.GOAL_DIRT:
                this.chipGoalCount -= 1;
                if (this.chipGoalCount < 0) {
                    this.chipGoalCount = 0;
                }
                this.goalLabel.setText(this.chipGoalCount.toString());
                break;
            default:
                break;
        }
    };
    LevelCreatorState.prototype.HideArrowsCount = function () {
        this.arrowsContainerCountGoal.removeAllChildren();
    };
    LevelCreatorState.prototype.HideArrowsGoal = function () {
        if (this.arrowsContainerGoal) {
            this.arrowsContainerGoal.removeAllChildren();
        }
    };
    LevelCreatorState.prototype.onChangeInputClick = function () {
        this.inputIterator = (this.inputIterator + 1) % this.inputModesArr.length;
        this.inputMode = this.inputModesArr[this.inputIterator];
        this.stateText.setText(this.inputMode);
    };
    LevelCreatorState.prototype.onPlayClick = function () {
        this.printLevelToConsole();
        StateManager.g_instance.pushState(new ShadeInState(new PlayState(-1, true)));
    };
    LevelCreatorState.prototype.createChipWithColorID = function (x, y, delay, id) {
        var have_cage = false;
        if (id >= 10) {
            have_cage = true;
            id -= 10;
        }
        var chip = new LevelCreatorChip(id, x, y);
        chip.setIncexes(x, y);
        if (have_cage) {
            chip.setCage();
        }
        this.addGameObjectAtPos(chip, this.backChipsLayer, this.getXPosByXIndex(x), this.getYPosByYIndex(y));
        this.field[x][y] = chip;
    };
    LevelCreatorState.prototype.getXPosByXIndex = function (x) {
        return x * Constants.CELL_SIZE + Constants.FIELD_OFFSET_X;
    };
    LevelCreatorState.prototype.getYPosByYIndex = function (y) {
        return y * Constants.CELL_SIZE + Constants.FIELD_OFFSET_Y;
    };
    LevelCreatorState.prototype.collectColorsOnField = function () {
        var colors = new Array();
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                if (this.field[x][y] != null && this.field[x][y].getColorID() >= 1 &&
                    this.field[x][y].getColorID() <= 7) {
                    if (colors.indexOf(this.field[x][y].getColorID()) == -1) {
                        colors.push(this.field[x][y].getColorID());
                    }
                }
            }
        }
        return colors;
    };
    LevelCreatorState.prototype.onMouseDown = function (x, y) {
        _super.prototype.onMouseDown.call(this, x, y);
        y -= this.y;
        var chip = this.findChipAt(x, y);
        if (chip) {
            switch (this.inputMode) {
                case LevelCreatorState.INPUT_MODE_FORM:
                    {
                        if (chip.isHole()) {
                            chip.convertHoleToChip();
                        }
                        else {
                            chip.convertToHole();
                            this.resetDirtAt(chip.getIndexX(), chip.getIndexY());
                        }
                        this.updateChipsButtons();
                    }
                    break;
                case LevelCreatorState.INPUT_MODE_OBSTACLE:
                    {
                        if (!chip.isHole()) {
                            if (chip.isObtacle()) {
                                chip.convertToObtacle(chip.getObstaclePower() == 2 ? 1 : 2);
                            }
                            else {
                                chip.convertToObtacle(2);
                            }
                        }
                        this.updateChipsButtons();
                    }
                    break;
                case LevelCreatorState.INPUT_MODE_CHIPS:
                    {
                        if (!chip.isHole()) {
                            chip.nextID();
                        }
                        this.updateChipsButtons();
                    }
                    break;
                case LevelCreatorState.INPUT_MODE_CAGE:
                    {
                        if (!chip.isHole()) {
                            if (chip.haveCage()) {
                                chip.removeCage();
                            }
                            else {
                                chip.setCage();
                            }
                        }
                        this.updateChipsButtons();
                    }
                    break;
                case LevelCreatorState.INPUT_MODE_STONEHEART:
                    {
                        if (!chip.isHole()) {
                            if (chip.isStoneHeart()) {
                                chip.convertHoleToChip();
                            }
                            else {
                                chip.convertToStoneHeart();
                            }
                        }
                        this.updateChipsButtons();
                    }
                    break;
                case LevelCreatorState.INPUT_MODE_DIRT:
                    {
                        if (!chip.isHole()) {
                            this.setDirtAt(chip.getIndexX(), chip.getIndexY());
                        }
                        this.updateChipsButtons();
                    }
                    break;
            }
        }
    };
    LevelCreatorState.prototype.resetDirtAt = function (x_index, y_index) {
        this.fieldDirt[x_index][y_index] = null;
        this.recalcDirt();
    };
    LevelCreatorState.prototype.setDirtAt = function (x_index, y_index) {
        if (this.fieldDirt[x_index][y_index] == null) {
            this.fieldDirt[x_index][y_index] = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_DIRT);
        }
        else {
            this.fieldDirt[x_index][y_index] = null;
        }
        this.recalcDirt();
    };
    LevelCreatorState.prototype.recalcDirt = function () {
        this.dirtLayer.removeAllChildren();
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                if (this.fieldDirt[x][y] != null) {
                    var dirt = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_DIRT);
                    dirt.x = this.getXPosByXIndex(x);
                    dirt.y = this.getYPosByYIndex(y);
                    this.dirtLayer.addChild(dirt);
                }
            }
        }
    };
    LevelCreatorState.prototype.spawnDefinedChips = function (chips) {
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                this.createChipWithColorID(x, y, (7 - y) * 0.13 + x * 0.11, chips[y][x]);
            }
        }
    };
    LevelCreatorState.prototype.findChipAt = function (x, y) {
        for (var x_index = 0; x_index < this.fieldWidth; x_index++) {
            for (var y_index = 0; y_index < this.fieldHeight; y_index++) {
                var chip = this.field[x_index][y_index];
                if (chip) {
                    if ((Math.abs(chip.x - x) < Constants.CELL_SIZE / 2) &&
                        (Math.abs(chip.y - y) < Constants.CELL_SIZE / 2)) {
                        return chip;
                    }
                }
            }
        }
        return null;
    };
    LevelCreatorState.prototype.getColorAt = function (x, y) {
        if (x < 0 || y < 0 || x >= this.fieldWidth || y >= this.fieldHeight || !this.field[x][y] == null) {
            return -1;
        }
        return this.field[x][y].getColorID();
    };
    LevelCreatorState.prototype.configureYAlign = function () {
        if (Constants.g_isPC) {
            return;
        }
        if (Constants.SCREEN_HEIGHT < Constants.ASSETS_HEIGHT) {
            this.y = Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT;
        }
        else if (Constants.SCREEN_HEIGHT > Constants.ASSETS_HEIGHT) {
            this.y = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
            var bottom_shape = new createjs.Shape();
            bottom_shape.graphics.beginFill("#b5389c");
            bottom_shape.graphics.drawRect(0, Constants.ASSETS_HEIGHT, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT + 1);
            bottom_shape.graphics.endFill();
            this.addChild(bottom_shape);
            var top_shape = new createjs.Shape();
            top_shape.graphics.beginFill("#b5389c");
            top_shape.graphics.drawRect(0, Constants.ASSETS_HEIGHT - Constants.SCREEN_HEIGHT, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT);
            top_shape.graphics.endFill();
            this.addChild(top_shape);
        }
    };
    return LevelCreatorState;
}(GameState));
LevelCreatorState.INPUT_MODE_CHIPS = "INPUT_MODE_CHIPS";
LevelCreatorState.INPUT_MODE_DIRT = "INPUT_MODE_DIRT";
LevelCreatorState.INPUT_MODE_FORM = "INPUT_MODE_FORM";
LevelCreatorState.INPUT_MODE_STONEHEART = "INPUT_MODE_STONEHEART";
LevelCreatorState.INPUT_MODE_CAGE = "INPUT_MODE_CAGE";
LevelCreatorState.INPUT_MODE_OBSTACLE = "INPUT_MODE_OBSTACLE";
LevelCreatorState.GOAL_DIRT = "GOAL_DIRT";
LevelCreatorState.GOAL_COUNT = "GOAL_COUNT";
LevelCreatorState.GOAL_SCORE = "GOAL_SCORE";
LevelCreatorState.GOAL_BONUS = "GOAL_BONUS";
/// <reference path="references.ts" />
var LightEffect = (function (_super) {
    __extends(LightEffect, _super);
    function LightEffect(delay, interval, count, scale, alpha) {
        var _this = _super.call(this) || this;
        _this.count = count;
        _this.interval = interval;
        _this.nextSpawnTime = delay;
        _this.isShowNow = false;
        _this.alpha = 0;
        _this.scale = scale;
        var pic = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_FLASH);
        pic.alpha = alpha;
        _this.addChild(pic);
        return _this;
    }
    LightEffect.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        if (this.liveTime > this.nextSpawnTime && !this.isShowNow) {
            this.isShowNow = true;
            this.liveTime = 0;
        }
        if (this.isShowNow) {
            this.rotation += dt * 180 * 1.3;
            this.scaleX = this.scaleY = Math.sin(this.liveTime * 3) * this.scale;
            this.alpha = 0.6 + Math.sin(this.liveTime * 3) * 0.3;
            if (this.liveTime * 3 > Math.PI) {
                this.count--;
                if (this.count <= 0) {
                    this.kill();
                }
                else {
                    this.liveTime = 0;
                    this.isShowNow = false;
                    this.nextSpawnTime = this.interval;
                }
            }
        }
    };
    return LightEffect;
}(GameObject));
/// <reference path="references.ts" />
var LoadingBar = (function (_super) {
    __extends(LoadingBar, _super);
    function LoadingBar(back_color, font_color, frame_color, fill_color) {
        var _this = _super.call(this) || this;
        _this.loadingShape = new createjs.Shape();
        _this.loadingShapeBack1 = new createjs.Shape();
        _this.loadingShapeBack2 = new createjs.Shape();
        _this.overrideBar = new createjs.Shape();
        _this.maxWidth = 300;
        _this.deltaY = 40;
        //this.overrideBar.graphics.beginFill(back_color);
        //this.overrideBar.graphics.drawRect(-8, -70, this.maxWidth + 16, 200);
        //this.overrideBar.graphics.endFill();
        //this.addChild(this.overrideBar);
        //this.overrideBar.x = -this.maxWidth / 2;
        _this.labelPercentDownload = new createjs.Text("Loading: 100%", "bold 35px Verdana", font_color);
        _this.labelPercentDownload.textAlign = "center"; /// need left
        //        this.addChild(this.labelPercentDownload);
        //--------------
        _this.loadingShapeBack1.graphics.beginFill(frame_color);
        _this.loadingShapeBack1.graphics.drawRect(0 - 4, 0 - 4, _this.maxWidth + 8, _this.deltaY + 8);
        _this.loadingShapeBack1.graphics.endFill();
        _this.addChild(_this.loadingShapeBack1);
        _this.loadingShape.graphics.beginFill(fill_color);
        _this.loadingShape.graphics.drawRect(0, 0, _this.maxWidth, _this.deltaY);
        _this.loadingShape.graphics.endFill();
        _this.addChild(_this.loadingShape);
        _this.loadingShape.scaleX = 0;
        _this.labelPercentDownload.y = -10;
        _this.loadingShape.x = -_this.maxWidth / 2;
        _this.loadingShape.y = +_this.deltaY * 1.5;
        _this.loadingShapeBack1.x = _this.loadingShape.x;
        _this.loadingShapeBack1.y = _this.loadingShape.y;
        return _this;
    }
    LoadingBar.prototype.setProgress = function (progress) {
        this.labelPercentDownload.text = "Loading: " + (progress * 100).toFixed(0) + "%";
        this.loadingShape.scaleX = progress;
    };
    return LoadingBar;
}(createjs.Container));
/// <reference path="references.ts" />
var PauseState = (function (_super) {
    __extends(PauseState, _super);
    function PauseState() {
        var _this = _super.call(this) || this;
        _this.panel = new createjs.Container();
        _this.hiddingNow = false;
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        //  shading
        _this.shader = new createjs.Shape();
        _this.shader.graphics.beginFill("#000000");
        _this.shader.graphics.drawRect(0, -diff, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT + diff);
        _this.shader.graphics.endFill();
        _this.addChild(_this.shader);
        _this.shader.alpha = 0;
        createjs.Tween.get(_this.shader, { loop: false }).wait(300).to({ alpha: 0.4 }, 800, createjs.Ease.linear);
        _this.addChild(_this.panel);
        _this.panel.x = Constants.ASSETS_WIDTH / 2;
        _this.panel.y = Constants.SCREEN_HEIGHT * 0.5;
        var panel = AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_MESSAGE_WINDOW);
        _this.panel.addChild(panel);
        var close_cross = new DNButton(Constants.IMAGE_BUTTON_CLOSE, function () { return _this.hide(); });
        _this.panel.addChild(close_cross);
        _this.addGuiObject(close_cross);
        close_cross.x = 180;
        close_cross.y = -180;
        var button_restart = new DNButton(Constants.IMAGE_BUTTON_RESTART, function () { return _this.onRestartTouch(); });
        _this.panel.addChild(button_restart);
        _this.addGuiObject(button_restart);
        button_restart.x = -150;
        button_restart.y = 100;
        var button_exit = new DNButton(Constants.IMAGE_BUTTON_EXIT, function () { return _this.onExitTouch(); });
        _this.panel.addChild(button_exit);
        _this.addGuiObject(button_exit);
        button_exit.x = 0;
        button_exit.y = 100;
        var pause_panel = AssetsManager.g_instance.getCenteredImageWithProxy("pause_panel");
        pause_panel.y = -50;
        _this.panel.addChild(pause_panel);
        var pause_text = new BitmapLabel(StringManager.getInstance().getString(StringManager.PAUSE));
        pause_text.alignH = DN_TEXT_ALIGN_HOR.CENTER;
        pause_text.alignW = DN_TEXT_ALIGN_VERT.MIDDLE;
        pause_text.y = -85;
        pause_text.x = 0;
        _this.panel.addChild(pause_text);
        _this.setSoundButton();
        _this.panel.alpha = 0.0;
        createjs.Tween.get(_this.panel, { loop: false }).to({ alpha: 1 }, 200, createjs.Ease.linear);
        _this.panel.y -= diff;
        _this.panel.scaleX = 0.7;
        _this.panel.scaleY = 0.7;
        createjs.Tween.get(_this.panel, { loop: false }).to({ scaleX: 1, scaleY: 1 }, 400, createjs.Ease.backOut);
        return _this;
    }
    PauseState.prototype.setSoundButton = function () {
        var _this = this;
        if (this.soundButton && this.soundButton.parent) {
            this.soundButton.parent.removeChild(this.soundButton);
        }
        var enabled = SoundManager.g_instance.isSoundEnabled();
        this.soundButton = new DNButton(enabled ? Constants.IMAGE_BUTTON_SOUND_ON : Constants.IMAGE_BUTTON_SOUND_OFF, function () { return _this.onSoundTouch(); });
        this.panel.addChild(this.soundButton);
        this.addGuiObject(this.soundButton); // mb bug
        this.soundButton.x = +150;
        this.soundButton.y = 100;
    };
    PauseState.prototype.hide = function () {
        if (!this.hiddingNow) {
            createjs.Tween.removeTweens(this.panel);
            createjs.Tween.removeTweens(this.shader);
            createjs.Tween.get(this.panel, { loop: false }).to({ alpha: 0 }, 200, createjs.Ease.linear);
            createjs.Tween.get(this.panel, { loop: false }).to({ scaleX: 0.7, scaleY: 0.7 }, 400, createjs.Ease.backOut)
                .call(function () { StateManager.g_instance.popState(); });
            createjs.Tween.get(this.shader, { loop: false }).to({ alpha: 0.0 }, 400, createjs.Ease.linear);
            this.hiddingNow = true;
        }
    };
    PauseState.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
    };
    PauseState.prototype.onRestartTouch = function () {
        if (enableAds == true) {
            try {
                if (StateManager.g_instance.adsCD <= 0) {
                    StateManager.g_instance.restartAdsCD();
                    adSense.showAdvertising();
                }
            }
            catch (e) {
            }
        }
        StateManager.g_instance.pushState(new ShadeInState(new PlayState(PlayState.g_curLevel, false)));
    };
    PauseState.prototype.onExitTouch = function () {
        if (enableAds == true) {
            try {
                if (StateManager.g_instance.adsCD <= 0) {
                    StateManager.g_instance.restartAdsCD();
                    adSense.showAdvertising();
                }
            }
            catch (e) {
            }
        }
        StateManager.g_instance.pushState(new GradientInState(new SelectLevelState()));
    };
    PauseState.prototype.onSoundTouch = function () {
        SoundManager.g_instance.calcSoundEnabled(!SoundManager.g_instance.isSoundEnabled());
        this.setSoundButton();
    };
    return PauseState;
}(GameState));
/// <reference path="references.ts" />
var PlayState = (function (_super) {
    __extends(PlayState, _super);
    function PlayState(level, show_task) {
        var _this = _super.call(this) || this;
        //  states for game mechanic
        _this.GAME_STATE_WAIT_SELECTION = "GAME_STATE_WAIT_SELECTION";
        _this.GAME_STATE_EXCHANGE = "GAME_STATE_EXCHANGE";
        _this.GAME_STATE_SPAWN = "GAME_STATE_SPAWN";
        _this.GAME_STATE_SHIFT = "GAME_STATE_SHIFT";
        _this.GAME_STATE_MATCHING = "GAME_STATE_MATCHING";
        //public INPUT_STATE_WAIT_SHAMAN: string = "INPUT_STATE_WAIT_SHAMAN";
        _this.state = null;
        _this.INPUT_STATE_WAIT = "INPUT_STATE_WAIT";
        _this.INPUT_STATE_NORMAL = "INPUT_STATE_NORMAL";
        _this.INPUT_STATE_SHAMAN = "INPUT_STATE_SHAMAN";
        _this.inputState = "INPUT_STATE_NORMAL"; //???
        _this.matchInARow = 0;
        _this.goal = PlayState.GOAL_DIRT;
        _this.goalLabel = new BitmapLabel("0");
        _this.chipGoalCount = 0;
        _this.dirtCount = 0;
        _this.fieldWidth = 8;
        _this.fieldHeight = 8;
        _this.selectedChip = null;
        _this.swapChip1 = null;
        _this.swapChip2 = null;
        _this.lastMovedChip = null;
        _this.dirtLayer = new createjs.Container();
        _this.underChipsLayer = new createjs.Container();
        _this.backChipsLayer = new createjs.Container();
        _this.holeLayer = new createjs.Container();
        _this.edgesLayer = new createjs.Container();
        _this.frontChipsLayer = new createjs.Container();
        _this.stateTime = 0;
        _this.tutorial = null;
        _this.score = 0;
        _this.tmpScore = 0;
        _this.scoreLabel = new BitmapLabel("00000");
        _this.moves = 30;
        _this.movesLabel = new BitmapLabel("50");
        _this.moveHint = null;
        _this.chipTypesCount = new Array();
        _this.awesomeEffectTime = 0;
        _this.superbEffectTime = 0;
        _this.waitLose = false;
        _this.waitLoseTime = 0;
        _this.waitWin = false;
        _this.waitWinTime = 0;
        _this.timeToBlink = 10;
        _this.outOfMovesShowed = false;
        _this.updateScoresCooldown = 0;
        _this.shaman = null;
        _this.taskShowed = false;
        _this.lastDropSoundTime = -10;
        _this.lastDropID = -1;
        _this.lastSound = null;
        _this.spawnCounter = 0;
        _this.spawnIDS = [
            3, 2, 1,
            1, 5, 1, 5,
            2, 4, 3, 2, 3, 4, 4,
            2, 4, 3, 2, 3, 4, 4,
            2, 4, 3, 2, 3, 4, 4 //  shaman match
        ];
        PlayState.g_curLevel = level;
        _this.y += 60;
        var back = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_BACK);
        back.x = Constants.ASSETS_WIDTH / 2;
        back.y = Constants.ASSETS_HEIGHT / 2;
        _this.addChild(back);
        PlayState.g_instance = _this;
        _this.chipTypesCount = GameData.getInstance().getLevelDef(level).chip_types;
        //  alloc
        _this.field = new Array(_this.fieldWidth);
        for (var i = 0; i < _this.fieldWidth; i++) {
            _this.field[i] = new Array(_this.fieldHeight);
        }
        _this.addChild(_this.dirtLayer);
        _this.addChild(_this.edgesLayer);
        _this.addChild(_this.underChipsLayer);
        _this.addChild(_this.backChipsLayer);
        _this.addChild(_this.holeLayer);
        _this.addChild(_this.frontChipsLayer);
        _this.matchInARow = 0;
        _this.spawnDefinedChips(GameData.getInstance().getLevelDef(level).chips);
        var form = GameData.getInstance().getLevelDef(level).form;
        for (var x = 0; x < _this.fieldWidth; x++) {
            for (var y = 0; y < _this.fieldHeight; y++) {
                if (form[y][x] == 0) {
                    _this.field[x][y].convertToHole();
                    _this.holeLayer.addChild(_this.field[x][y]);
                }
            }
        }
        //  alloc dirt
        _this.fieldDirt = new Array(_this.fieldWidth);
        for (var i = 0; i < _this.fieldWidth; i++) {
            _this.fieldDirt[i] = new Array(_this.fieldHeight);
        }
        var dirt_template = GameData.getInstance().getLevelDef(level).dirt;
        if (dirt_template) {
            for (var x = 0; x < _this.fieldWidth; x++) {
                for (var y = 0; y < _this.fieldHeight; y++) {
                    if (dirt_template[y][x] != 0) {
                        _this.dirtCount++;
                        var dirt = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_DIRT);
                        dirt.x = _this.getXPosByXIndex(x) - 1;
                        dirt.y = _this.getYPosByYIndex(y) + 3;
                        _this.dirtLayer.addChild(dirt);
                        _this.fieldDirt[x][y] = dirt;
                    }
                }
            }
        }
        _this.holeLayer.cache(0, 0, Constants.ASSETS_WIDTH, Constants.ASSETS_HEIGHT, 1);
        _this.edgesLayer.cache(0, 0, Constants.ASSETS_WIDTH, Constants.ASSETS_HEIGHT, 1);
        //  create frames around holes
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        //---------- gui overlaps
        var gui = AssetsManager.g_instance.getImage(Constants.IMAGE_GUI);
        gui.y -= 140;
        _this.addChild(gui);
        var goal_type = GameData.getInstance().getLevelDef(level).goal_type;
        switch (goal_type) {
            case PlayState.GOAL_COUNT:
                _this.goal = PlayState.GOAL_COUNT;
                _this.goalChipID = GameData.getInstance().getLevelDef(level).chip_goal;
                _this.chipGoalCount = GameData.getInstance().getLevelDef(level).chip_goal_count;
                _this.goalLabel.setText(_this.chipGoalCount.toString());
                var goal_sprite = AssetsManager.g_instance.getCenteredImageWithProxy("cake_" + _this.goalChipID);
                goal_sprite.scaleX = goal_sprite.scaleY = 0.66;
                _this.addChild(goal_sprite);
                goal_sprite.x = 516;
                goal_sprite.y = 77;
                break;
            case PlayState.GOAL_DIRT:
                _this.goal = PlayState.GOAL_DIRT;
                var dirt_sprite = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_DIRT);
                dirt_sprite.scaleX = dirt_sprite.scaleY = 0.45;
                _this.addChild(dirt_sprite);
                dirt_sprite.x = 516;
                dirt_sprite.y = 77;
                _this.goalLabel.setText(_this.dirtCount.toString());
                break;
            case PlayState.GOAL_SCORE:
                _this.goal = PlayState.GOAL_SCORE;
                _this.chipGoalCount = GameData.getInstance().getLevelDef(level).chip_goal_count;
                _this.goalLabel.setText(_this.chipGoalCount.toString());
                var goal_sprite = AssetsManager.g_instance.getCenteredImageWithProxy("score_bonus");
                goal_sprite.scaleX = goal_sprite.scaleY = 0.66;
                _this.addChild(goal_sprite);
                goal_sprite.x = 516;
                goal_sprite.y = 77;
                _this.updateGoalScoreLabel(0);
                break;
            case PlayState.GOAL_BONUS:
                _this.goal = PlayState.GOAL_BONUS;
                _this.goalBonustype = GameData.getInstance().getLevelDef(level).chip_goal_bonus;
                _this.chipGoalCount = GameData.getInstance().getLevelDef(level).chip_goal_count;
                _this.goalLabel.setText(_this.chipGoalCount.toString());
                var goal_sprite = AssetsManager.g_instance.getCenteredImageWithProxy(PlayState.getImageByBonusType(_this.goalBonustype));
                goal_sprite.scaleX = goal_sprite.scaleY = 0.66;
                _this.addChild(goal_sprite);
                goal_sprite.x = 516;
                goal_sprite.y = 77;
                break;
            default:
                break;
        }
        var pause_proxy = new createjs.Container();
        //pause_proxy.scaleX = pause_proxy.scaleY = 0.9;
        var button_pause = new DNButton(Constants.IMAGE_BUTTON_PAUSE, function () { return _this.onPauseClick(); });
        pause_proxy.addChild(button_pause);
        _this.addGuiObject(button_pause);
        pause_proxy.x = 80;
        pause_proxy.y = 95;
        _this.addChild(pause_proxy);
        _this.addChild(_this.scoreLabel);
        _this.scoreLabel.x = 300;
        _this.scoreLabel.y = 27;
        _this.scoreLabel.scaleX = _this.scoreLabel.scaleY = 0.7;
        _this.moves = GameData.getInstance().getLevelDef(level).moves;
        _this.addChild(_this.movesLabel);
        _this.movesLabel.x = 275;
        _this.movesLabel.y = 82;
        _this.movesLabel.scaleX = _this.movesLabel.scaleY = 0.7;
        _this.movesLabel.setText(_this.moves.toString());
        //  ???
        _this.addChild(_this.goalLabel);
        _this.goalLabel.x = _this.goal == PlayState.GOAL_SCORE ? 607 : 580;
        _this.goalLabel.y = 53;
        _this.goalLabel.scaleX = _this.goalLabel.scaleY = 0.7;
        _this.taskShowed = !show_task;
        if (level == 0) {
            _this.tutorial = new Tutorial();
            _this.addGameObject(_this.tutorial);
            _this.tutorial.onStartRound();
        }
        if (show_task && !_this.tutorial) {
            var task = new TaskEffect(_this.goal, _this.chipGoalCount, _this.goalChipID, _this.goalBonustype, function () { return _this.setTaskShowed(); });
            _this.addGameObject(task);
            _this.addChild(task);
        }
        else {
            _this.setTaskShowed();
        }
        _this.alignByCenter();
        return _this;
    }
    PlayState.prototype.getGoal = function () {
        return this.goal;
    };
    PlayState.getImageByBonusType = function (bonus_type) {
        switch (bonus_type) {
            case Chip.BONUS_BOMB:
                return Constants.IMAGE_BONUS_BOMB;
            case Chip.BONUS_COLOR:
                return Constants.IMAGE_BONUS_COLOR;
            case Chip.BONUS_CROSS:
                return Constants.IMAGE_BONUS_CROSS_GUI;
            case Chip.BONUS_SHAMAN:
                return Constants.IMAGE_BONUS_SHAMAN;
        }
    };
    PlayState.prototype.onPauseClick = function () {
        StateManager.g_instance.pushState(new PauseState());
    };
    PlayState.prototype.createChip = function (x, y, delay) {
        var id = this.chipTypesCount[Utils.RandomRangeInt(0, this.chipTypesCount.length - 1)];
        var chip = new Chip(id, x, y, this.getXPosByXIndex(x), this.getYPosByYIndex(y), delay);
        chip.setIncexes(x, y);
        this.addGameObjectAtPos(chip, this.backChipsLayer, this.getXPosByXIndex(x), -Constants.CELL_SIZE);
        this.field[x][y] = chip;
    };
    PlayState.prototype.createChipWithColorID = function (x, y, delay, id) {
        var have_cage = false;
        if (id >= 10) {
            have_cage = true;
            id -= 10;
        }
        var chip = new Chip(id, x, y, this.getXPosByXIndex(x), this.getYPosByYIndex(y), delay);
        if (have_cage) {
            chip.setCage();
        }
        chip.setIncexes(x, y);
        this.addGameObjectAtPos(chip, this.backChipsLayer, this.getXPosByXIndex(x), -Constants.CELL_SIZE);
        //  ??? bla bla bibb
        if (chip.isObtacle() || chip.haveCage()) {
            chip.y = this.getYPosByYIndex(y);
        }
        this.field[x][y] = chip;
    };
    PlayState.prototype.blinkChips = function (offset) {
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                var chip = this.field[x][y];
                if (chip && chip.getColorID() != -1) {
                    this.addGameObjectAtPos(new LightEffect(offset + x * 0.07 + y * 0.07, 8, 1, 0.30, 0.85), chip, Utils.RandomRange(-15, +15), Utils.RandomRange(-15, +15));
                }
            }
        }
    };
    PlayState.prototype.getXPosByXIndex = function (x) {
        return x * Constants.CELL_SIZE + Constants.FIELD_OFFSET_X;
    };
    PlayState.prototype.getYPosByYIndex = function (y) {
        return y * Constants.CELL_SIZE + Constants.FIELD_OFFSET_Y;
    };
    PlayState.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        if ((this.timeToBlink -= dt) <= 0) {
            this.timeToBlink = 10;
            this.blinkChips(0);
        }
        if (this.waitWin) {
            this.waitWinTime += dt;
            if (PlayState.g_instance.INPUT_STATE_SHAMAN == this.inputState || this.updateScoresCooldown < 0.5) {
                this.waitWinTime -= dt;
            }
            if (this.waitWinTime > 1) {
                StateManager.g_instance.pushState(new WinState(PlayState.g_curLevel, this.score));
                return;
            }
        }
        if (this.waitLose) {
            if (this.waitWin) {
                this.waitLose = false;
                return;
            }
            this.waitLoseTime += dt;
            if (PlayState.g_instance.INPUT_STATE_SHAMAN == this.inputState || this.updateScoresCooldown < 0.5) {
                this.waitLoseTime -= dt;
            }
            if (this.updateScoresCooldown > 0.5 && !this.outOfMovesShowed) {
                SoundManager.g_instance.play(SoundManager.SOUND_LOSE);
                this.addGameObjectAt(new TimeIsUpEffect(Constants.IMAGE_OUT_OF_MOVES), this);
                this.outOfMovesShowed = true;
            }
            if (this.waitLoseTime > 1) {
                StateManager.g_instance.pushState(new GameOverState(0, 0));
                return;
            }
        }
        this.stateTime += dt;
        if (this.state != this.GAME_STATE_WAIT_SELECTION) {
            if (this.moveHint) {
                if (this.moveHint.isDead()) {
                    this.moveHint = null;
                }
                else {
                    this.moveHint.hide();
                }
            }
        }
        //  update input state
        switch (this.inputState) {
            case this.INPUT_STATE_SHAMAN:
                if (this.shaman && this.shaman.isDead()) {
                    this.shaman = null;
                    this.setInputState(this.INPUT_STATE_NORMAL);
                }
                break;
        }
        switch (this.state) {
            //case this.INPUT_STATE_WAIT_SHAMAN:
            //    if (this.shaman && this.shaman.isDead())
            //    {
            //        this.shaman = null;
            //        this.checkEmptyCells();
            //        this.shiftChips();
            //    }
            //    break;
            case this.GAME_STATE_WAIT_SELECTION:
                {
                    this.checkForEmptyCells();
                    var tm = (this.tutorial != null ? 0.3 : 4.0);
                    if (this.stateTime > tm && this.moveHint && !this.moveHint.parent && !this.shaman) {
                        this.addGameObjectAt(this.moveHint, this.frontChipsLayer);
                    }
                }
                break;
            case this.GAME_STATE_SPAWN:
                if (this.allChipsNormal()) {
                    this.matchMatches(this.findMatches());
                }
                break;
            case this.GAME_STATE_SHIFT:
                if (this.allChipsNormal()) {
                    this.matchMatches(this.findMatches());
                }
                break;
            case this.GAME_STATE_MATCHING:
                if (this.stateTime > Constants.MATCH_TIME / 2) {
                    this.shiftChip();
                }
                break;
        }
        this.updateScoresCooldown = this.updateScoresCooldown > 10 ? 10 : this.updateScoresCooldown + dt;
        //  update score label
        if (this.tmpScore < this.score) {
            var diff = this.tmpScore;
            this.tmpScore += 17;
            if (this.tmpScore > this.score) {
                this.tmpScore = this.score;
            }
            this.updateScoresCooldown = 0;
            diff = this.tmpScore - diff;
            var str_score = this.tmpScore.toString();
            switch (str_score.length) {
                case 1:
                    str_score = "0000" + str_score;
                    break;
                case 2:
                    str_score = "000" + str_score;
                    break;
                case 3:
                    str_score = "00" + str_score;
                    break;
                case 4:
                    str_score = "0" + str_score;
                    break;
            }
            this.scoreLabel.setText(str_score);
            if (this.goal == PlayState.GOAL_SCORE) {
                this.updateGoalScoreLabel(diff);
            }
        }
    };
    PlayState.prototype.checkForEmptyCells = function () {
        var chips = this.findMatches();
        if (chips) {
            this.matchMatches(chips);
        }
        if (this.checkEmptyCells()) {
            this.shiftChip();
        }
    };
    PlayState.prototype.checkEmptyCells = function () {
        var chips = new Array();
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                if (this.field[x][y] == null) {
                    return true;
                }
            }
        }
        return false;
    };
    PlayState.prototype.updateGoalScoreLabel = function (diff) {
        if (this.chipGoalCount > 0) {
            this.chipGoalCount -= diff;
            if (this.chipGoalCount <= 0) {
                this.chipGoalCount = 0;
                this.win();
            }
            var str_score = this.chipGoalCount.toString();
            switch (str_score.length) {
                case 1:
                    str_score = "0000" + str_score;
                    break;
                case 2:
                    str_score = "000" + str_score;
                    break;
                case 3:
                    str_score = "00" + str_score;
                    break;
                case 4:
                    str_score = "0" + str_score;
                    break;
            }
            this.goalLabel.setText(str_score);
        }
    };
    PlayState.prototype.allChipsNormal = function () {
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                if (this.field[x][y] != null && !this.field[x][y].isNormal()) {
                    return false;
                }
            }
        }
        return true;
    };
    PlayState.prototype.needSpawn = function () {
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                if (this.field[x][y] == null) {
                    return true;
                }
            }
        }
        return false;
    };
    PlayState.prototype.canExchange = function (chip_1, chip_2) {
        if (chip_1 == chip_2) {
            return false;
        }
        if (chip_1.isHole() || chip_2.isHole()) {
            return false;
        }
        if (chip_1.isObtacle() || chip_2.isObtacle()) {
            return false;
        }
        var x_dist = (chip_1.getIndeces().x - chip_2.getIndeces().x);
        var y_dist = (chip_1.getIndeces().y - chip_2.getIndeces().y);
        return (Math.abs(x_dist) == 1 && y_dist == 0) || (Math.abs(y_dist) == 1 && x_dist == 0);
    };
    PlayState.prototype.exchangeChips = function (chip_1, chip_2) {
        var _this = this;
        var chip_1_x = chip_1.x;
        var chip_1_y = chip_1.y;
        var chip_1_index_x = chip_1.getIndexX();
        var chip_1_index_y = chip_1.getIndexY();
        var chip_2_x = chip_2.x;
        var chip_2_y = chip_2.y;
        var chip_2_index_x = chip_2.getIndexX();
        var chip_2_index_y = chip_2.getIndexY();
        //  
        this.field[chip_1_index_x][chip_1_index_y] = chip_2;
        this.field[chip_2_index_x][chip_2_index_y] = chip_1;
        chip_1.exchange(chip_2_index_x, chip_2_index_y);
        chip_2.exchange(chip_1_index_x, chip_1_index_y);
        this.swapChip1 = chip_1;
        this.swapChip2 = chip_2;
        createjs.Tween.get(chip_1).to({ x: chip_2_x, y: chip_2_y }, Constants.EXCHANGE_TIME * 1000, createjs.Ease.linear).call(function () { return _this.onExchangeEnded(); });
        createjs.Tween.get(chip_2).to({ x: chip_1_x, y: chip_1_y }, Constants.EXCHANGE_TIME * 1000, createjs.Ease.linear);
        this.selectedChip = null;
        this.setState(this.GAME_STATE_EXCHANGE);
    };
    PlayState.prototype.addConverToBonusEffect = function (chip) {
        var effect = new ConvertToBonusEffect(chip);
        //this.addGameObjectAtPos(effect, this, chip.x, chip.y - Constants.CELL_SIZE / 2);
        this.addGameObjectAtPos(effect, this.underChipsLayer, chip.x, chip.y);
    };
    PlayState.prototype.matchMatches = function (mached_chips) {
        if (mached_chips.length != 0) {
            if (this.tutorial) {
                this.tutorial.onMatch();
            }
            switch (this.matchInARow) {
                case 0:
                    SoundManager.g_instance.play(SoundManager.SOUND_MATCH_1);
                    break;
                case 1:
                    SoundManager.g_instance.play(SoundManager.SOUND_MATCH_2);
                    break;
                case 2:
                    SoundManager.g_instance.play(SoundManager.SOUND_MATCH_3);
                    break;
                case 3:
                    SoundManager.g_instance.play(SoundManager.SOUND_MATCH_4);
                    break;
                default:
                    SoundManager.g_instance.play(SoundManager.SOUND_MATCH_5);
                    break;
            }
            var was_line_bonus_convert = false;
            for (var chip_set = 0; chip_set < mached_chips.length; chip_set++) {
                for (var i = 0; i < mached_chips[chip_set].length; i++) {
                    mached_chips[chip_set][i].match(Chip.MATCH_REASON_SIMPLE);
                }
            }
            for (var chip_set = 0; chip_set < mached_chips.length; chip_set++) {
                var need_break = false;
                if (mached_chips[chip_set].length >= 5) {
                    var was_convert = false;
                    for (var ch = 0; ch < mached_chips[chip_set].length; ch++) {
                        if (mached_chips[chip_set][ch] == this.swapChip1) {
                            this.lastMovedChip = this.swapChip1;
                        }
                        if (mached_chips[chip_set][ch] == this.swapChip2) {
                            this.lastMovedChip = this.swapChip2;
                        }
                        if (mached_chips[chip_set][ch] == this.lastMovedChip) {
                            was_line_bonus_convert = true;
                            was_convert = true;
                            need_break = true;
                            this.lastMovedChip.convertToBonus(Chip.BONUS_COLOR);
                            this.lastMovedChip = null;
                            break;
                        }
                    }
                    if (!was_convert) {
                        was_line_bonus_convert = true;
                        mached_chips[chip_set][Utils.RandomRangeInt(1, mached_chips[chip_set].length - 2)].convertToBonus(Chip.BONUS_COLOR);
                    }
                }
            }
            if (!need_break) {
                for (var chip_set = 0; chip_set < mached_chips.length; chip_set++) {
                    //  match 4 in a raw
                    if (mached_chips[chip_set].length == 4) {
                        var was_convert = false;
                        for (var ch = 0; ch < mached_chips[chip_set].length; ch++) {
                            if (mached_chips[chip_set][ch] == this.swapChip1) {
                                this.lastMovedChip = this.swapChip1;
                            }
                            if (mached_chips[chip_set][ch] == this.swapChip2) {
                                this.lastMovedChip = this.swapChip2;
                            }
                            if (mached_chips[chip_set][ch] == this.lastMovedChip) {
                                var is_horiz_cross = true;
                                if (mached_chips[chip_set][0].getIndexX() == mached_chips[chip_set][1].getIndexX()) {
                                    is_horiz_cross = false;
                                }
                                was_convert = true;
                                was_line_bonus_convert = true;
                                this.lastMovedChip.convertToBonus(Chip.BONUS_CROSS, is_horiz_cross);
                                this.lastMovedChip = null;
                                break;
                            }
                        }
                        if (!was_convert) {
                            var is_horiz_cross = true;
                            if (mached_chips[chip_set][0].getIndexX() == mached_chips[chip_set][1].getIndexX()) {
                                is_horiz_cross = false;
                            }
                            was_line_bonus_convert = true;
                            mached_chips[chip_set][Utils.RandomRangeInt(1, 2)].convertToBonus(Chip.BONUS_CROSS, is_horiz_cross);
                        }
                    }
                    for (var i = 0; i < mached_chips[chip_set].length; i++) {
                        if (mached_chips[chip_set][i].isDoubleMatched()) {
                            mached_chips[chip_set][i].convertToBonus(Chip.BONUS_BOMB);
                            chip_set = 100; //break2 emulation
                            break;
                        }
                    }
                }
            }
            this.setState(this.GAME_STATE_MATCHING);
        }
        else {
            this.shiftChip();
        }
    };
    //  first parameter - bonus chip
    PlayState.prototype.matchBonus = function (bonus_chip, chip2) {
        if (this.tutorial && bonus_chip.getBonusType() == Chip.BONUS_SHAMAN) {
            this.showTaskTutorial();
        }
        if (bonus_chip.isMatching()) {
            return;
        }
        if (chip2) {
            chip2.match(Chip.MATCH_REASON_EXCHANGE_WIHT_BONUS);
        }
        bonus_chip.match(Chip.MATCH_REASON_I_AM_BONUS);
        if (bonus_chip.getBonusType() == Chip.BONUS_CROSS) {
            SoundManager.g_instance.play(SoundManager.SOUND_LINE);
            if (this.goal == PlayState.GOAL_BONUS && this.goalBonustype == Chip.BONUS_CROSS) {
                this.chipGoalCount--;
                if (this.chipGoalCount <= 0) {
                    this.chipGoalCount = 0;
                    this.win();
                }
                this.goalLabel.setText(this.chipGoalCount.toString());
            }
            if (bonus_chip.isChipHorizCross()) {
                var match_y = bonus_chip.getIndexY();
                for (var i = 0; i < this.fieldWidth; i++) {
                    if (this.field[i][match_y] != null) {
                        if (this.field[i][match_y].isBonus()) {
                            this.matchBonus(this.field[i][match_y], null);
                        }
                        else {
                            this.field[i][match_y].match(Chip.MATCH_REASON_BONUS_EFFECT_4_HOR);
                        }
                    }
                }
                this.addGameObjectAtPos(new KillLineEffect(new createjs.Point(+1200, 0)), this.frontChipsLayer, bonus_chip.x, bonus_chip.y);
                this.addGameObjectAtPos(new KillLineEffect(new createjs.Point(-1200, 0)), this.frontChipsLayer, bonus_chip.x, bonus_chip.y);
            }
            else {
                var match_x = bonus_chip.getIndexX();
                for (var i = 0; i < this.fieldHeight; i++) {
                    if (this.field[match_x][i] != null) {
                        if (this.field[match_x][i].isBonus()) {
                            this.matchBonus(this.field[match_x][i], null);
                        }
                        else {
                            this.field[match_x][i].match(Chip.MATCH_REASON_BONUS_EFFECT_4_VERT);
                        }
                    }
                }
                this.addGameObjectAtPos(new KillLineEffect(new createjs.Point(0, -1200)), this, bonus_chip.x, bonus_chip.y);
                this.addGameObjectAtPos(new KillLineEffect(new createjs.Point(0, +1200)), this, bonus_chip.x, bonus_chip.y);
            }
        }
        if (bonus_chip.getBonusType() == Chip.BONUS_SHAMAN) {
            this.runShaman();
            if (this.goal == PlayState.GOAL_BONUS && this.goalBonustype == Chip.BONUS_SHAMAN) {
                this.chipGoalCount--;
                if (this.chipGoalCount <= 0) {
                    this.chipGoalCount = 0;
                    this.win();
                }
                this.goalLabel.setText(this.chipGoalCount.toString());
            }
        }
        if (bonus_chip.getBonusType() == Chip.BONUS_COLOR) {
            var effect_from = new createjs.Point(bonus_chip.x, bonus_chip.y);
            if (this.goal == PlayState.GOAL_BONUS && this.goalBonustype == Chip.BONUS_COLOR) {
                this.chipGoalCount--;
                if (this.chipGoalCount <= 0) {
                    this.chipGoalCount = 0;
                    this.win();
                }
                this.goalLabel.setText(this.chipGoalCount.toString());
            }
            var color_id;
            if (!chip2) {
                var colors = this.collectColorsOnField();
                color_id = colors[Utils.RandomRangeInt(0, colors.length - 1)];
            }
            else {
                color_id = chip2.getColorID();
            }
            SoundManager.g_instance.play(SoundManager.SOUND_KILL_COLOR);
            if (color_id != -1) {
                for (var x = 0; x < this.fieldWidth; x++) {
                    for (var y = 0; y < this.fieldHeight; y++) {
                        if (this.field[x][y] != null) {
                            if (this.field[x][y].getColorID() == color_id) {
                                var effect_to = new createjs.Point(this.field[x][y].x, this.field[x][y].y);
                                this.addGameObjectAtPos(new KillColorEffect(effect_from, effect_to), this, effect_from.x, effect_from.y);
                                this.field[x][y].match(Chip.MATCH_REASON_BONUS_EFFECT_5);
                            }
                        }
                    }
                }
            }
        }
        if (bonus_chip.getBonusType() == Chip.BONUS_BOMB) {
            if (this.goal == PlayState.GOAL_BONUS && this.goalBonustype == Chip.BONUS_BOMB) {
                this.chipGoalCount--;
                if (this.chipGoalCount <= 0) {
                    this.chipGoalCount = 0;
                    this.win();
                }
                this.goalLabel.setText(this.chipGoalCount.toString());
            }
            this.boom(bonus_chip);
        }
        this.setState(this.GAME_STATE_MATCHING);
    };
    PlayState.prototype.collectColorsOnField = function () {
        var colors = new Array();
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                if (this.field[x][y] != null && this.field[x][y].getColorID() >= 1 &&
                    this.field[x][y].getColorID() <= 7 && this.field[x][y].isNormal()) {
                    if (colors.indexOf(this.field[x][y].getColorID()) == -1) {
                        colors.push(this.field[x][y].getColorID());
                    }
                }
            }
        }
        return colors;
    };
    PlayState.prototype.boom = function (chip) {
        SoundManager.g_instance.play(SoundManager.SOUND_BOOM);
        var chip_x = chip.getIndexX();
        var chip_y = chip.getIndexY();
        var damage_zone = [
            [0, 0, 1, 0, 0],
            [0, 1, 1, 1, 0],
            [1, 1, 1, 1, 1],
            [0, 1, 1, 1, 0],
            [0, 0, 1, 0, 0],
        ];
        for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
                if (damage_zone[x][y] != 0) {
                    var new_x = chip_x + x - 2;
                    var new_y = chip_y + y - 2;
                    if (this.validCoords(new_x, new_y) && this.field[new_x][new_y] != null) {
                        if (this.field[new_x][new_y].isBonus()) {
                            this.matchBonus(this.field[new_x][new_y], null);
                        }
                        else {
                            this.field[new_x][new_y].match(Chip.MATCH_REASON_BONUS_EFFECT_5);
                        }
                    }
                }
            }
        }
        //var radius = 1;
        //for (var x: number = chip_x - radius; x <= chip_x + radius; x++)
        //{
        //    for (var y: number = chip_y - radius; y <= chip_y + radius; y++)
        //    {
        //        if (this.validCoords(x, y) && this.field[x][y] != null)
        //        {
        //            if (this.field[x][y].isBonus())
        //            {
        //                this.matchBonus(this.field[x][y], null);
        //            }
        //            else
        //            {
        //                this.field[x][y].match(Chip.MATCH_REASON_BONUS_EFFECT_4_HOR);
        //            }
        //        }
        //    }
        //}
        var effect = new AutoreleaseEffect("explosion_big_", 9, 0.05);
        effect.scaleX = effect.scaleY = 1.4;
        effect.rotation = 360 * Math.random();
        this.addGameObjectAtPos(effect, this, chip.x, chip.y);
    };
    PlayState.prototype.validCoords = function (x, y) {
        return x >= 0 && x < this.fieldWidth && y >= 0 && y < this.fieldHeight;
    };
    PlayState.prototype.onExchangeEnded = function () {
        var first_exchange = (this.swapChip1 != null || this.swapChip2 != null);
        var is_bonus_exchange = false;
        if (this.swapChip1 != null && this.swapChip2 != null) {
            var is_first_chip_bonus = this.swapChip1.isBonus().valueOf(), is_second_chip_bonus = this.swapChip2.isBonus().valueOf(), is_one_stone = this.swapChip1.isStoneHeart() || this.swapChip2.isStoneHeart(), is_one_color = this.swapChip1.getBonusType() == Chip.BONUS_COLOR || this.swapChip2.getBonusType() == Chip.BONUS_COLOR, is_one_shaman = this.swapChip1.getBonusType() == Chip.BONUS_SHAMAN || this.swapChip2.getBonusType() == Chip.BONUS_SHAMAN;
        }
        if (first_exchange) {
            if (this.swapChip1.isBonus()) {
                is_bonus_exchange = true;
            }
            if (this.swapChip2.isBonus()) {
                is_bonus_exchange = true;
            }
            if (this.swapChip1.isBonus() && this.swapChip2.isBonus() && this.swapChip1.getBonusType() != Chip.BONUS_SHAMAN &&
                this.swapChip2.getBonusType() != Chip.BONUS_SHAMAN) {
                if (this.goal == PlayState.GOAL_BONUS) {
                    if (this.goalBonustype == this.swapChip1.getBonusType()) {
                        this.chipGoalCount--;
                        if (this.chipGoalCount <= 0) {
                            this.chipGoalCount = 0;
                            this.win();
                        }
                        this.goalLabel.setText(this.chipGoalCount.toString());
                    }
                    if (this.goalBonustype == this.swapChip2.getBonusType()) {
                        this.chipGoalCount--;
                        if (this.chipGoalCount <= 0) {
                            this.chipGoalCount = 0;
                            this.win();
                        }
                        this.goalLabel.setText(this.chipGoalCount.toString());
                    }
                }
                this.swapChip2.match(Chip.MATCH_REASON_I_AM_BONUS);
                this.swapChip1.convertToBonus(Chip.BONUS_SHAMAN);
                if (this.tutorial) {
                    this.tutorial.onMatch();
                }
                this.setState(this.GAME_STATE_MATCHING);
            }
        }
        var mached_chips = this.findMatches();
        var decreased = false;
        if (mached_chips.length == 0) {
            if (!is_bonus_exchange) {
                if (first_exchange) {
                    this.exchangeChips(this.swapChip1, this.swapChip2);
                    //  no match, exchange back this time!
                    this.swapChip1 = null;
                    this.swapChip2 = null;
                }
                else {
                    //  ok, this time exchange failed. Try one more time!
                    this.setState(this.GAME_STATE_WAIT_SELECTION);
                }
            }
            else {
                if (is_one_color && is_one_stone) {
                    this.exchangeChips(this.swapChip1, this.swapChip2);
                    //  no match, exchange back this time!
                    this.swapChip1 = null;
                    this.swapChip2 = null;
                    return;
                }
            }
        }
        else {
            //  moves 
            this.decreseMoves();
            decreased = true;
            this.matchMatches(mached_chips);
        }
        //  match bonuses here
        if (first_exchange && is_bonus_exchange) {
            var both_bonuses = this.swapChip1.isBonus() && this.swapChip2.isBonus();
            if (is_one_shaman && both_bonuses) {
                this.matchBonus(this.swapChip1, null);
                this.matchBonus(this.swapChip2, null);
            }
            if (is_first_chip_bonus && !both_bonuses) {
                this.matchBonus(this.swapChip1, this.swapChip2);
            }
            if (is_second_chip_bonus && !both_bonuses) {
                this.matchBonus(this.swapChip2, this.swapChip1);
            }
            if (!decreased) {
                this.decreseMoves();
            }
        }
    };
    PlayState.prototype.decreseMoves = function () {
        this.moves--;
        if (this.moves < 0) {
            this.moves = 0;
        }
        this.movesLabel.setText(this.moves.toString());
    };
    PlayState.prototype.findMatches = function () {
        var mached_chips = Array();
        for (var y = 0; y < this.fieldHeight; y++) {
            for (var x = 0; x < this.fieldWidth;) {
                var start_color_id = -1;
                var matches_count = 0; //  first item matches with itself  ???
                var mached_chips_array = new Array();
                //  looking for horizontal matches
                for (var i = x; i < this.fieldWidth; i++) {
                    if (this.field[i][y] == null || this.field[i][y].isBonus() || this.field[i][y].getColorID() == -1) {
                        break;
                    }
                    else {
                        if (start_color_id == -1) {
                            start_color_id = this.field[i][y].getColorID();
                        }
                    }
                    if (this.field[i][y].getColorID() == start_color_id) {
                        mached_chips_array.push(this.field[i][y]);
                        matches_count++;
                    }
                    else {
                        break;
                    }
                }
                if (matches_count >= 3) {
                    mached_chips.push(mached_chips_array);
                }
                if (matches_count != 0) {
                    x += matches_count;
                }
                else {
                    x++;
                }
            }
        }
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y) {
                var start_color_id = -1;
                var matches_count = 0; //  first item matches with itself  ???
                var mached_chips_array = new Array();
                //  looking for vertical matches
                for (var i = y; i < this.fieldHeight; i++) {
                    if (this.field[x][i] == null || this.field[x][i].isBonus() || this.field[x][i].getColorID() == -1) {
                        break;
                    }
                    else {
                        if (start_color_id == -1) {
                            start_color_id = this.field[x][i].getColorID();
                        }
                    }
                    if (this.field[x][i].getColorID() == start_color_id) {
                        mached_chips_array.push(this.field[x][i]);
                        matches_count++;
                    }
                    else {
                        break;
                    }
                }
                if (matches_count >= 3) {
                    mached_chips.push(mached_chips_array);
                }
                if (matches_count != 0) {
                    y += matches_count;
                }
                else {
                    y++;
                }
            }
        }
        return mached_chips;
    };
    PlayState.prototype.killByLighting = function (chip) {
        var effect = new AutoreleaseEffect("lighting_", 6, 0.055);
        var h = 314;
        var scale = (chip.y + 150) / h;
        effect.scaleY = scale;
        this.addGameObjectAtPos(effect, this, chip.x, chip.y - h * scale * 0.5 + 25 * scale);
        this.addPointsAt(chip, chip.getMatchReason());
        var explosion = new AutoreleaseEffect("explosion_", 6, 0.05);
        explosion.rotation = Math.random() * 360;
        this.addGameObjectAtPosWithDelay(explosion, this, chip.x, chip.y, 0.25);
        SoundManager.g_instance.play(SoundManager.SOUND_VERTICAL_LIGHTING);
        if (chip.isBonus()) {
            this.matchBonus(chip, null);
        }
        else {
            chip.matchByLighting();
            //  ???
            this.setState(this.GAME_STATE_MATCHING);
        }
    };
    PlayState.prototype.runShaman = function () {
        if (!this.shaman || this.shaman.isDead()) {
            if (this.moveHint) {
                this.moveHint.hide();
            }
            this.shaman = new Shaman();
            this.addGameObjectAt(this.shaman, this);
            this.addGameObject(new TaskChipKiller());
            this.setInputState(this.INPUT_STATE_SHAMAN);
        }
    };
    PlayState.prototype.killTaskChip = function () {
        var chips = new Array();
        switch (this.goal) {
            case PlayState.GOAL_COUNT:
                for (var x = 0; x < this.fieldWidth; x++) {
                    for (var y = 0; y < this.fieldHeight; y++) {
                        if (this.field[x][y] && this.field[x][y].isNormal() && this.field[x][y].getColorID() == this.goalChipID) {
                            chips.push(this.field[x][y]);
                        }
                    }
                }
                break;
            case PlayState.GOAL_DIRT:
                for (var x = 0; x < this.fieldWidth; x++) {
                    for (var y = 0; y < this.fieldHeight; y++) {
                        if (this.fieldDirt[x][y] != null) {
                            chips.push(this.field[x][y]);
                        }
                    }
                }
                break;
            case PlayState.GOAL_SCORE:
                for (var x = 0; x < this.fieldWidth; x++) {
                    for (var y = 0; y < this.fieldHeight; y++) {
                        if (this.field[x][y] && this.field[x][y].isNormal() && this.field[x][y].getColorID() != -1) {
                            chips.push(this.field[x][y]);
                        }
                    }
                }
                break;
            default:
                break;
        }
        if (chips.length == 0) {
            for (var x = 0; x < this.fieldWidth; x++) {
                for (var y = 0; y < this.fieldHeight; y++) {
                    if (this.field[x][y] && this.field[x][y].isNormal() && this.field[x][y].getColorID() != -1) {
                        chips.push(this.field[x][y]);
                    }
                }
            }
        }
        if (chips.length != 0) {
            this.killByLighting(chips[Utils.RandomRangeInt(0, chips.length - 1)]);
        }
    };
    PlayState.prototype.convertChipToBonusCross = function (x_index, y_number) {
        this.field[x_index][y_number].convertToBonus(Chip.BONUS_CROSS, Math.random() > 0.5 ? true : false);
    };
    PlayState.prototype.setTaskShowed = function () {
        this.taskShowed = true;
        if (this.tutorialHightlighter) {
            this.tutorialHightlighter.hide();
        }
    };
    PlayState.prototype.onMouseUp = function (x, y) {
        _super.prototype.onMouseUp.call(this, x, y);
        y -= this.y;
        //this.selectedChip = null;
    };
    PlayState.prototype.onMouseDown = function (x, y) {
        _super.prototype.onMouseDown.call(this, x, y);
        if (this.state != this.GAME_STATE_WAIT_SELECTION) {
            return;
        }
        if (this.inputState != this.INPUT_STATE_NORMAL) {
            return;
        }
        if (this.waitLose || this.waitWin) {
            return;
        }
        if (!this.taskShowed) {
            return;
        }
        y -= this.y;
        var chip = this.checkChipSelection(x, y);
        if (chip) {
            if (chip.haveCage()) {
                return;
            }
            if (this.tutorial && !this.tutorial.isAccessibleChip(chip)) {
                return;
            }
            if (chip == this.selectedChip) {
                return;
            }
            if (!this.selectedChip) {
                this.selectedChip = chip;
                this.selectedChip.select();
            }
            else {
                if (this.canExchange(this.selectedChip, chip)) {
                    this.lastMovedChip = this.selectedChip;
                    //this.exchangeChips(chip, this.selectedChip);
                    this.exchangeChips(this.selectedChip, chip);
                    //  ???
                    SoundManager.g_instance.play(SoundManager.SOUND_EXCHANGE);
                }
                else {
                    this.selectedChip.deselect();
                    this.selectedChip = chip;
                    this.selectedChip.select();
                }
            }
        }
    };
    PlayState.prototype.onMouseMove = function (x, y) {
        _super.prototype.onMouseMove.call(this, x, y);
        if (this.state != this.GAME_STATE_WAIT_SELECTION) {
            return;
        }
        this.onMouseDown(x, y);
    };
    PlayState.prototype.isValidCoords = function (x, y) {
        return x >= 0 && y >= 0 && x < this.fieldWidth && y < this.fieldHeight;
    };
    PlayState.prototype.shiftChip = function () {
        var moved = false, moved_down = false;
        var moves = 0;
        do {
            moved = false;
            moved_down = this.shiftOnlyDown();
            if (moved_down) {
                moves++;
            }
            for (var x_index = this.fieldWidth - 1; x_index >= 0; x_index--) {
                for (var y_index = this.fieldHeight - 1; y_index >= 0; y_index--) {
                    if (this.field[x_index][y_index] && !this.field[x_index][y_index].isStoneHeart() && !this.field[x_index][y_index].isObtacle()
                        && !this.field[x_index][y_index].haveCage() && !this.field[x_index][y_index].isHole()) {
                        if (this.isValidCoords(x_index + 1, y_index + 1) && this.field[x_index + 1][y_index + 1] == null) {
                            this.field[x_index][y_index].isLeft = false;
                            this.field[x_index][y_index].shiftDownChip(x_index + 1, this.getXPosByXIndex(x_index + 1), y_index + 1, this.getYPosByYIndex(y_index + 1));
                            this.field[x_index + 1][y_index + 1] = this.field[x_index][y_index];
                            this.field[x_index][y_index] = null;
                            moves++;
                            moved = true;
                        }
                        else if (this.isValidCoords(x_index - 1, y_index + 1) && this.field[x_index - 1][y_index + 1] == null) {
                            this.field[x_index][y_index].isLeft = true;
                            this.field[x_index][y_index].shiftDownChip(x_index - 1, this.getXPosByXIndex(x_index - 1), y_index + 1, this.getYPosByYIndex(y_index + 1));
                            this.field[x_index - 1][y_index + 1] = this.field[x_index][y_index];
                            this.field[x_index][y_index] = null;
                            moves++;
                            moved = true;
                        }
                    }
                }
            }
            for (var x_index = 0; x_index < this.fieldWidth; x_index++) {
                for (var y_index = this.fieldHeight - 1; y_index >= 0; y_index--) {
                    if (this.field[x_index][y_index] && !this.field[x_index][y_index].isStoneHeart() && !this.field[x_index][y_index].isObtacle()
                        && !this.field[x_index][y_index].haveCage() && !this.field[x_index][y_index].isHole()) {
                        if (this.isValidCoords(x_index + 1, y_index + 1) && this.field[x_index + 1][y_index + 1] == null) {
                            this.field[x_index][y_index].isLeft = false;
                            this.field[x_index][y_index].shiftDownChip(x_index + 1, this.getXPosByXIndex(x_index + 1), y_index + 1, this.getYPosByYIndex(y_index + 1));
                            this.field[x_index + 1][y_index + 1] = this.field[x_index][y_index];
                            this.field[x_index][y_index] = null;
                            moves++;
                            moved = true;
                        }
                        else if (this.isValidCoords(x_index - 1, y_index + 1) && this.field[x_index - 1][y_index + 1] == null) {
                            this.field[x_index][y_index].isLeft = true;
                            this.field[x_index][y_index].shiftDownChip(x_index - 1, this.getXPosByXIndex(x_index - 1), y_index + 1, this.getYPosByYIndex(y_index + 1));
                            this.field[x_index - 1][y_index + 1] = this.field[x_index][y_index];
                            this.field[x_index][y_index] = null;
                            moves++;
                            moved = true;
                        }
                    }
                }
            }
        } while (moved_down || moved);
        this.setState(this.GAME_STATE_SHIFT);
        this.spawnNewChips();
        if (moves > 0) {
            return true;
        }
        return false;
    };
    PlayState.prototype.shiftOnlyDown = function () {
        var moved = false;
        var moves = 0;
        do {
            moved = false;
            for (var x_index = 0; x_index < this.fieldWidth; x_index++) {
                for (var y_index = this.fieldHeight - 1; y_index >= 0; y_index--) {
                    if (this.field[x_index][y_index] && !this.field[x_index][y_index].haveCage() && !this.field[x_index][y_index].isHole() &&
                        !this.field[x_index][y_index].isObtacle()) {
                        if (this.field[x_index][y_index + 1] == null && y_index + 1 < this.fieldHeight) {
                            this.field[x_index][y_index].shiftDownChip(x_index, this.getXPosByXIndex(x_index), y_index + 1, this.getYPosByYIndex(y_index + 1));
                            this.field[x_index][y_index + 1] = this.field[x_index][y_index];
                            this.field[x_index][y_index] = null;
                            moved = true;
                            moves++;
                        }
                    }
                }
            }
        } while (moved);
        if (moves > 0) {
            this.setState(this.GAME_STATE_SHIFT);
            return true;
        }
        else {
            return false;
        }
    };
    PlayState.prototype.spawnNewChips = function () {
        var spawned_count = 0;
        for (var x = 0; x < this.fieldWidth; x++) {
            var count = -1;
            for (var y = this.fieldHeight - 1; y >= 0; y--) {
                if (this.field[x][y] == null) {
                    if (count == -1) {
                        count = y;
                    }
                    spawned_count++;
                    if (this.tutorial) {
                        this.createChipWithColorID(x, y, (count - y) * 0.13, this.getTutorialSpawnNewID());
                    }
                    else {
                        this.createChip(x, y, (count - y) * 0.13);
                    }
                }
            }
        }
        if (spawned_count > 0) {
            this.setState(this.GAME_STATE_SPAWN);
        }
        else {
            this.setState(this.GAME_STATE_WAIT_SELECTION);
        }
    };
    PlayState.prototype.spawnDefinedChips = function (chips) {
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                this.createChipWithColorID(x, y, (7 - y) * 0.13 + x * 0.11, chips[y][x]);
            }
        }
        this.setState(this.GAME_STATE_SPAWN);
        this.blinkChips(3.0);
    };
    PlayState.prototype.checkChipSelection = function (x, y) {
        //  can just calculate cell without loop
        for (var x_index = 0; x_index < this.fieldWidth; x_index++) {
            for (var y_index = 0; y_index < this.fieldHeight; y_index++) {
                var chip = this.field[x_index][y_index];
                if (chip) {
                    if ((Math.abs(chip.x - x) < Constants.CELL_SIZE / 2) &&
                        (Math.abs(chip.y - y) < Constants.CELL_SIZE / 2)) {
                        return chip;
                    }
                }
            }
        }
        return null;
    };
    PlayState.prototype.setInputState = function (input_state) {
        this.inputState = input_state;
    };
    PlayState.prototype.setState = function (state) {
        this.state = state;
        this.stateTime = 0.0;
        var pixel_ratio = (window.devicePixelRatio ? window.devicePixelRatio : 1);
        var width = window.innerWidth * pixel_ratio;
        var height = window.innerHeight * pixel_ratio;
        if (this.state == this.GAME_STATE_WAIT_SELECTION) {
            this.matchInARow = 0;
            if (this.findMoves()) {
                var chip_1 = this.field[this.findedMatchPos1.x][this.findedMatchPos1.y];
                var chip_2 = this.field[this.findedMatchPos2.x][this.findedMatchPos2.y];
                this.moveHint = new MoveHint(this.findedMatchPos1.y != this.findedMatchPos2.y);
                this.moveHint.x = (chip_1.x + chip_2.x) / 2;
                this.moveHint.y = (chip_1.y + chip_2.y) / 2;
            }
            else {
                //  convert to random bonus random chip
                //  BUG HERE cant convert HOLE
                this.moveHint = null;
                while (true) {
                    var chip = this.field[Utils.RandomRangeInt(0, this.fieldWidth - 1)][Utils.RandomRangeInt(0, this.fieldHeight - 1)];
                    if (!chip.isHole() && !chip.isBonus() && !chip.isStoneHeart() && !chip.isObtacle() && !chip.haveCage()) {
                        chip.convertToBonus([Chip.BONUS_BOMB, Chip.BONUS_CROSS, Chip.BONUS_COLOR][Utils.RandomRangeInt(0, 2)]);
                        //????? shift here sometime
                        this.shiftChip();
                        break;
                    }
                }
            }
            if (this.moves <= 0) {
                if (this.inputState != this.INPUT_STATE_SHAMAN) {
                    this.lose();
                }
            }
        }
    };
    PlayState.prototype.clearCell = function (chip) {
        var x = chip.getIndexX();
        var y = chip.getIndexY();
        if (this.field[x][y] == chip) {
            if (this.goal == PlayState.GOAL_COUNT) {
                if (chip.getColorID() == this.goalChipID) {
                    this.chipGoalCount--;
                    if (this.chipGoalCount <= 0) {
                        this.chipGoalCount = 0;
                        this.win();
                    }
                    this.goalLabel.setText(this.chipGoalCount.toString());
                }
            }
            if (chip.getMatchReason() == Chip.MATCH_REASON_BONUS_EFFECT_5 ||
                chip.getMatchReason() == Chip.MATCH_REASON_BONUS_EFFECT_4_HOR ||
                chip.getMatchReason() == Chip.MATCH_REASON_BONUS_EFFECT_4_VERT) {
                this.runParticleEffect(chip.x, chip.y);
            }
            this.field[x][y] = null;
        }
        this.tryClearDirt(x, y);
        if (!chip.isStoneHeart()) {
            this.tryClearStoneHeart(x, y);
        }
        if (!chip.isObtacle()) {
            this.tryClearObtacles(x, y, chip.getMatchReason());
        }
    };
    PlayState.prototype.tryClearDirt = function (x, y) {
        var dirt = this.fieldDirt[x][y];
        if (dirt) {
            createjs.Tween.get(dirt, { loop: false }).to({ alpha: 0 }, 250, createjs.Ease.linear);
            //dirt.parent.removeChild(dirt);
            this.fieldDirt[x][y] = null;
            if (--this.dirtCount == 0) {
                this.win();
            }
        }
        if (this.goal == PlayState.GOAL_DIRT) {
            this.goalLabel.setText(this.dirtCount.toString());
        }
    };
    PlayState.prototype.tryClearObtacles = function (x, y, match_reason) {
        var chip;
        if (match_reason == Chip.MATCH_REASON_SIMPLE ||
            match_reason == Chip.MATCH_REASON_EXCHANGE_WIHT_BONUS ||
            match_reason == Chip.MATCH_REASON_I_AM_BONUS) {
            chip = this.getChipAt(x + 1, y);
            if (chip && chip.isObtacle()) {
                chip.damage();
            }
            chip = this.getChipAt(x - 1, y);
            if (chip && chip.isObtacle()) {
                chip.damage();
            }
            chip = this.getChipAt(x, y + 1);
            if (chip && chip.isObtacle()) {
                chip.damage();
            }
            chip = this.getChipAt(x, y - 1);
            if (chip && chip.isObtacle()) {
                chip.damage();
            }
        }
        else {
            //  hz
            chip = this.getChipAt(x, y);
            if (chip && chip.isObtacle()) {
                chip.damage();
            }
        }
    };
    PlayState.prototype.tryClearStoneHeart = function (x, y) {
        var chip;
        chip = this.getChipAt(x + 1, y);
        if (chip && chip.isStoneHeart()) {
            chip.match(Chip.MATCH_REASON_NEAR);
        }
        chip = this.getChipAt(x - 1, y);
        if (chip && chip.isStoneHeart()) {
            chip.match(Chip.MATCH_REASON_NEAR);
        }
        chip = this.getChipAt(x, y + 1);
        if (chip && chip.isStoneHeart()) {
            chip.match(Chip.MATCH_REASON_NEAR);
        }
        chip = this.getChipAt(x, y - 1);
        if (chip && chip.isStoneHeart()) {
            chip.match(Chip.MATCH_REASON_NEAR);
        }
    };
    PlayState.prototype.highlightArea = function (left, top, right, bottom) {
        var highlighter = new TutorialHighlighter(this.getXPosByXIndex(left) - Constants.CELL_SIZE / 2, this.getYPosByYIndex(top) - Constants.CELL_SIZE / 2, this.getXPosByXIndex(right) - Constants.CELL_SIZE / 2, this.getYPosByYIndex(bottom) - Constants.CELL_SIZE / 2);
        this.addGameObjectAt(highlighter, this);
        return highlighter;
    };
    PlayState.prototype.finishLevel = function () {
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                if (this.field[x][y] != null && this.field[x][y].isNormal()) {
                    this.field[x][y].fallDown();
                }
            }
        }
    };
    PlayState.prototype.lose = function () {
        if (!this.waitLose) {
            this.waitLose = true;
        }
    };
    PlayState.prototype.win = function () {
        if (!this.waitWin) {
            this.waitWin = true;
            SoundManager.g_instance.play(SoundManager.SOUND_WIN);
        }
    };
    PlayState.prototype.haveMoves = function () {
        for (var x = 0; x < this.fieldWidth; x++) {
            for (var y = 0; y < this.fieldHeight; y++) {
                if (this.field[x][y] != null && this.field[x][y].isBonus()) {
                    return true;
                }
            }
        }
        //    return false;
        return true;
    };
    PlayState.prototype.addPointsAt = function (chip, match_reason) {
        if (chip.getBonusType() == null) {
            var points = 40;
            switch (match_reason) {
                case Chip.MATCH_REASON_EXCHANGE_WIHT_BONUS:
                    points = 40;
                    break;
                case Chip.MATCH_REASON_BONUS_EFFECT_5:
                    points = 100;
                    break;
                case Chip.MATCH_REASON_BONUS_EFFECT_4_HOR:
                    points = 90;
                    break;
                case Chip.MATCH_REASON_BONUS_EFFECT_4_VERT:
                    points = 120;
                    break;
                case Chip.MATCH_REASON_I_AM_BONUS:
                    points = 150;
                    break;
                default:
                    points = 40 + this.matchInARow * 20;
                    break;
            }
            var effect = new FlyingPoints(points);
            this.score += points;
            var pos_x = chip.x;
            var pos_y = chip.y;
            //if (!this.tryShowAwesome(chip.x, chip.y) || !this.tryShowSuperb(chip.x, chip.y))   //  awesome except points
            {
                this.addGameObjectAtPos(effect, this.frontChipsLayer, pos_x, pos_y);
            }
        }
        else {
            if (chip.getBonusType() == Chip.BONUS_BOMB) {
                //  bomb effects
                //SoundManager.g_instance.play(SoundManager.SOUND_ADD_TIME);
                //this.addGameObjectAtPos(new AddTimeEffect(), this, chip.x - Constants.CELL_SIZE / 2, chip.y - Constants.CELL_SIZE / 2);
            }
        }
    };
    PlayState.prototype.findMoves = function () {
        var right_hor_pattern = [[2, -1], [3, 0], [2, 1]];
        var left_hor_pattern = [[-1, -1], [-2, 0], [-1, 1]];
        var center_hor_pattern = [[1, -1], [1, 1]];
        //////  2 horizontal in a row
        for (var y = 0; y < this.fieldHeight; y++) {
            for (var x = 0; x < this.fieldWidth - 1; x++) {
                if (this.field[x][y] != null && this.field[x + 1][y] != null && this.field[x][y].getColorID() == this.field[x + 1][y].getColorID()) {
                    if (this.findPattern(x, y, this.field[x][y].getColorID(), right_hor_pattern, x + 2, y)) {
                        return true;
                    }
                    if (this.findPattern(x, y, this.field[x][y].getColorID(), left_hor_pattern, x - 1, y)) {
                        return true;
                    }
                }
            }
        }
        //  2 horizontal with hole at center
        for (var y = 0; y < this.fieldHeight; y++) {
            for (var x = 0; x < this.fieldWidth - 2; x++) {
                if (this.field[x][y].getColorID() == this.field[x + 2][y].getColorID()) {
                    if (this.findPattern(x, y, this.field[x][y].getColorID(), center_hor_pattern, x + 1, y)) {
                        return true;
                    }
                }
            }
        }
        var bottom_vert_pattern = [[-1, 2], [0, 3], [1, 2]];
        var top_vert_pattern = [[-1, -1], [0, -2], [1, -1]];
        var center_vert_pattern = [[-1, 1], [1, 1]];
        //--------------------------------------------------------
        ////  2 vertical in a row
        for (var y = 0; y < this.fieldHeight - 1; y++) {
            for (var x = 0; x < this.fieldWidth; x++) {
                if (this.field[x][y].getColorID() == this.field[x][y + 1].getColorID()) {
                    if (this.findPattern(x, y, this.field[x][y].getColorID(), bottom_vert_pattern, x, y + 2)) {
                        return true;
                    }
                    if (this.findPattern(x, y, this.field[x][y].getColorID(), top_vert_pattern, x, y - 1)) {
                        return true;
                    }
                }
            }
        }
        //  2 vertical with hole at center
        for (var y = 0; y < this.fieldHeight - 2; y++) {
            for (var x = 0; x < this.fieldWidth; x++) {
                if (this.field[x][y].getColorID() == this.field[x][y + 2].getColorID()) {
                    if (this.findPattern(x, y, this.field[x][y].getColorID(), center_vert_pattern, x, y + 1)) {
                        return true;
                    }
                }
            }
        }
        for (var y = 0; y < this.fieldHeight; y++) {
            for (var x = 0; x < this.fieldWidth; x++) {
                if (this.field[x][y].isBonus()) {
                    if (this.validCoords(x - 1, y) && (this.field[x - 1][y].isChip() || this.field[x - 1][y].isBonus())) {
                        if (this.tutorial == null) {
                            this.findedMatchPos1 = this.field[x][y].getIndeces();
                            this.findedMatchPos2 = this.field[x - 1][y].getIndeces();
                        }
                        return true;
                    }
                    if (this.validCoords(x + 1, y) && (this.field[x + 1][y].isChip() || this.field[x + 1][y].isBonus())) {
                        if (this.tutorial == null) {
                            this.findedMatchPos1 = this.field[x][y].getIndeces();
                            this.findedMatchPos2 = this.field[x + 1][y].getIndeces();
                        }
                        return true;
                    }
                    if (this.validCoords(x, y + 1) && (this.field[x][y + 1].isChip() || this.field[x][y + 1].isBonus())) {
                        if (this.tutorial == null) {
                            this.findedMatchPos1 = this.field[x][y].getIndeces();
                            this.findedMatchPos2 = this.field[x][y + 1].getIndeces();
                        }
                        return true;
                    }
                    if (this.validCoords(x, y - 1) && (this.field[x][y - 1].isChip() || this.field[x][y - 1].isBonus())) {
                        if (this.tutorial == null) {
                            this.findedMatchPos1 = this.field[x][y].getIndeces();
                            this.findedMatchPos2 = this.field[x][y - 1].getIndeces();
                        }
                        return true;
                    }
                }
            }
        }
        return false;
    };
    PlayState.prototype.findPattern = function (x, y, color, pattern, sec_x, sec_y) {
        //  bonus cant match
        if (color <= 0) {
            return false;
        }
        //  bug here ????
        if (sec_x < 0 || sec_x >= this.fieldWidth || sec_y < 0 || sec_y >= this.fieldHeight) {
            return false;
        }
        if (this.field[sec_x][sec_y] && !this.field[sec_x][sec_y].movable()) {
            return false;
        }
        for (var i = 0; i < pattern.length; i++) {
            var col_at = this.getColorAt(x + pattern[i][0], y + pattern[i][1]);
            if (col_at <= 0) {
                continue;
            }
            //  find any of pattern
            if (col_at == color) {
                if (this.field[sec_x][sec_y].haveCage()) {
                    continue;
                }
                if (this.field[x + pattern[i][0]][y + pattern[i][1]].haveCage()) {
                    continue;
                }
                if (this.tutorial == null) {
                    this.findedMatchPos1 = new createjs.Point(sec_x, sec_y);
                    this.findedMatchPos2 = new createjs.Point(x + pattern[i][0], y + pattern[i][1]);
                }
                return true;
            }
        }
        return false;
    };
    PlayState.prototype.setHintIndeces = function (x1, y1, x2, y2) {
        this.findedMatchPos1 = new createjs.Point(x1, y1);
        this.findedMatchPos2 = new createjs.Point(x2, y2);
    };
    PlayState.prototype.getChipAt = function (x, y) {
        if (x < 0 || y < 0 || x >= this.fieldWidth || y >= this.fieldHeight || !this.field[x][y] || this.field[x][y].isHole()) {
            return null;
        }
        return this.field[x][y];
    };
    PlayState.prototype.getColorAt = function (x, y) {
        if (x < 0 || y < 0 || x >= this.fieldWidth || y >= this.fieldHeight || !this.field[x][y] == null) {
            return -1;
        }
        return this.field[x][y].getColorID();
    };
    PlayState.prototype.onShiftEnded = function () {
        if (this.liveTime != this.lastDropSoundTime) {
            this.lastDropSoundTime = this.liveTime;
            var id = Utils.RandomRangeInt(0, 2);
            while (id == this.lastDropID) {
                id = Utils.RandomRangeInt(0, 2);
            }
            this.lastDropID = id;
            switch (id) {
                case 0:
                    this.lastSound = SoundManager.g_instance.play(SoundManager.SOUND_DROP_1);
                    break;
                case 1:
                    this.lastSound = SoundManager.g_instance.play(SoundManager.SOUND_DROP_2);
                    break;
                case 2:
                    this.lastSound = SoundManager.g_instance.play(SoundManager.SOUND_DROP_3);
                    break;
            }
        }
    };
    PlayState.prototype.configureYAlign = function () {
        if (Constants.g_isPC) {
            return;
        }
        if (Constants.SCREEN_HEIGHT < Constants.ASSETS_HEIGHT) {
            this.y = Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT;
        }
        else if (Constants.SCREEN_HEIGHT > Constants.ASSETS_HEIGHT) {
            this.y = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
            var bottom_shape = new createjs.Shape();
            bottom_shape.graphics.beginFill("#b5389c");
            bottom_shape.graphics.drawRect(0, Constants.ASSETS_HEIGHT, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT + 1);
            bottom_shape.graphics.endFill();
            this.addChild(bottom_shape);
            var top_shape = new createjs.Shape();
            top_shape.graphics.beginFill("#b5389c");
            top_shape.graphics.drawRect(0, Constants.ASSETS_HEIGHT - Constants.SCREEN_HEIGHT, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT);
            top_shape.graphics.endFill();
            this.addChild(top_shape);
        }
    };
    PlayState.prototype.getTutorialSpawnNewID = function () {
        if (this.spawnCounter >= this.spawnIDS.length) {
            return this.chipTypesCount[Utils.RandomRangeInt(0, this.chipTypesCount.length - 1)];
        }
        return this.spawnIDS[this.spawnCounter++];
    };
    PlayState.prototype.showTaskTutorial = function () {
        var _this = this;
        PlayState.needShowTutorial = false;
        if (this.tutorial) {
            this.tutorial.kill();
            this.tutorial = null;
        }
        this.taskShowed = false;
        this.addGameObject(new DNTimer(8.5, 1, function () {
            _this.tutorialHightlighter = new TutorialHighlighter(_this.goalLabel.x - 150, _this.goalLabel.y - 20, _this.goalLabel.x + 75, _this.goalLabel.y + 70);
            _this.addGameObjectAt(_this.tutorialHightlighter, _this);
            var task = new TaskEffect(_this.goal, _this.chipGoalCount, _this.goalChipID, _this.goalBonustype, function () { return _this.setTaskShowed(); }, true);
            _this.addGameObject(task);
            _this.addChild(task);
        }));
    };
    PlayState.prototype.getGoalCount = function () {
        return this.chipGoalCount;
    };
    PlayState.prototype.runParticleEffect = function (pos_x, pos_y) {
        var speed = 80;
        var count = Utils.RandomRangeInt(3, 4);
        for (var i = 0; i < count; i++) {
            var angle = Utils.RadToGrad(Utils.RandomRange(0, 360));
            var effect = new HeartParticle(Math.cos(angle) * speed, Math.sin(angle) * speed);
            this.addGameObject(effect);
            this.addChild(effect);
            effect.x = pos_x + Utils.RandomRange(-Constants.CELL_SIZE / 3, Constants.CELL_SIZE / 3);
            effect.y = pos_y + Utils.RandomRange(-Constants.CELL_SIZE / 3, Constants.CELL_SIZE / 3);
        }
    };
    return PlayState;
}(GameState));
PlayState.g_curLevel = -1;
PlayState.needShowTutorial = false;
PlayState.GOAL_DIRT = "GOAL_DIRT";
PlayState.GOAL_COUNT = "GOAL_COUNT";
PlayState.GOAL_BONUS = "GOAL_BONUS";
PlayState.GOAL_SCORE = "GOAL_SCORE";
/// <reference path="references.ts" />
var PreloaderState = (function (_super) {
    __extends(PreloaderState, _super);
    function PreloaderState(manifest, sound_manifest, athlases, localizable_images) {
        var _this = _super.call(this) || this;
        _this.loadingBar = new LoadingBar("#000000", "#ffffff", "#666666", "#ffffff");
        new AssetsManager(manifest, sound_manifest, athlases, localizable_images, function (e) { return _this.handleProgress(e); });
        _this.addChild(_this.loadingBar);
        _this.loadingBar.x = Constants.ASSETS_WIDTH / 2;
        _this.loadingBar.y = Constants.ASSETS_HEIGHT / 2;
        return _this;
    }
    PreloaderState.prototype.handleProgress = function (e) {
        this.loadingBar.setProgress(e.loaded);
    };
    PreloaderState.prototype.onOrientationChanged = function (is_landscape) {
        //  do nothing
    };
    return PreloaderState;
}(GameState));
/// <reference path="references.ts" />
var SelectLevelButton = (function (_super) {
    __extends(SelectLevelButton, _super);
    function SelectLevelButton(name, callback, num) {
        var _this = _super.call(this) || this;
        _this.locked = false;
        _this.selected = false;
        _this.func = null;
        _this.enabled = true;
        _this.func = callback;
        _this.levelNum = num;
        _this.setHandler(function () { return StateManager.g_instance.pushState(new GradientInState(new PlayState(_this.levelNum, true))); });
        if (num < GameData.getInstance().levelsAvailable()) {
            _this.picture = AssetsManager.g_instance.getCenteredImageWithProxy(name);
            _this.addChild(_this.picture);
            _this.picWidth = _this.picture.getBounds().width * 1.15;
            _this.picHeight = _this.picture.getBounds().height * 1.15;
            var text = new BitmapLabel((num + 1).toString());
            var flag = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_LEVEL_BUTTON_FLAG);
            flag.x = 0;
            flag.y = 0;
            _this.addChild(flag);
            flag.addChild(text);
            text.alignH = DN_TEXT_ALIGN_HOR.CENTER;
            text.alignW = DN_TEXT_ALIGN_VERT.MIDDLE;
            //"#255E8C8"
            var scale = 0.65;
            text.scaleX = text.scaleY = scale;
            text.x = -text.getBounds().width / 2 * scale + 40;
            text.y = -text.getBounds().height / 2 * scale - 77;
        }
        else {
            _this.locked = true;
            _this.picture = AssetsManager.g_instance.getCenteredImageWithProxy(name);
            var lock = AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_LOCK);
            lock.scaleX = lock.scaleY = 0.8;
            lock.y += 30;
            _this.picture = new createjs.Container();
            _this.picture.addChild(lock);
            _this.picWidth = _this.picture.getBounds().width * 1.15;
            _this.picHeight = _this.picture.getBounds().height * 1.15;
            _this.addChild(_this.picture);
        }
        return _this;
    }
    SelectLevelButton.prototype.getPicture = function () {
        return this.picture;
    };
    SelectLevelButton.prototype.isAvailable = function () {
        return !this.locked;
    };
    SelectLevelButton.prototype.setHandler = function (callback) {
        this.func = callback;
    };
    SelectLevelButton.prototype.select = function () {
        if (!this.selected && !this.locked) {
            //createjs.Tween.removeTweens(this.picture);
            this.setPicture(Constants.IMAGE_LEVEL_BUTTON_DOWN);
            //createjs.Tween.get(this.picture).to({ scaleX: 1.15, scaleY: 1.15 }, 150, createjs.Ease.linear);
            this.selected = true;
        }
    };
    SelectLevelButton.prototype.setPicture = function (pic) {
        this.removeChild(this.picture);
        this.picture = AssetsManager.g_instance.getCenteredImageWithProxy(pic);
        this.addChild(this.picture);
    };
    SelectLevelButton.prototype.deselect = function () {
        if (this.selected && !this.locked) {
            //createjs.Tween.removeTweens(this.picture);
            this.setPicture(Constants.IMAGE_LEVEL_BUTTON);
            //createjs.Tween.get(this.picture).to({ scaleX: 1.0, scaleY: 1.0 }, 150, createjs.Ease.linear);
            this.selected = false;
        }
    };
    SelectLevelButton.prototype.onMouseDown = function (x, y) {
        if (this.hitTestSmart(x, y)) {
            this.liveTime = 0;
            this.select();
        }
        this.touchY = y;
    };
    SelectLevelButton.prototype.onMouseUp = function (x, y) {
        if (this.hitTestSmart(x, y) && this.selected) {
            if (Math.abs(y - this.touchY) > 30) {
                this.deselect();
                return;
            }
            if (!GUIObject.wasHandlerThisFrame) {
                GUIObject.wasHandlerThisFrame = true;
                this.func();
                //  run action
                SoundManager.g_instance.play(SoundManager.SOUND_CLICK);
            }
        }
        this.deselect();
    };
    SelectLevelButton.prototype.onMouseMove = function (x, y) {
        if (!this.hitTestSmart(x, y)) {
            this.deselect();
        }
    };
    SelectLevelButton.prototype.hitTestSmart = function (x, y) {
        if (!this.enabled) {
            return;
        }
        if (!this.parent || !this.visible) {
            return false;
        }
        var pos = this.picture.localToGlobal(0, 0);
        pos.x /= Constants.SCREEN_SCALE;
        pos.y /= Constants.SCREEN_SCALE;
        var w = this.picture.getBounds().width * 0.3 * this.scaleX;
        var h = this.picture.getBounds().height * 0.3 * this.scaleY;
        return pos.x < x + w && pos.x > x - w && pos.y < y + h && pos.y > y - h;
    };
    SelectLevelButton.prototype.setEnabled = function (enabled) {
        this.enabled = enabled;
    };
    return SelectLevelButton;
}(GUIObject));
/// <reference path="references.ts" />
var Shaman = (function (_super) {
    __extends(Shaman, _super);
    function Shaman() {
        var _this = _super.call(this) || this;
        _this.hidding = false;
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        //  shading
        _this.shader = new createjs.Shape();
        _this.shader.graphics.beginFill("#000000");
        _this.shader.graphics.drawRect(0, -diff - 60, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT + diff + 100);
        _this.shader.graphics.endFill();
        _this.addChild(_this.shader);
        _this.shader.alpha = 0;
        createjs.Tween.get(_this.shader).to({ alpha: 0.5 }, 800, createjs.Ease.linear);
        _this.crystal = AssetsManager.g_instance.getCenteredImageWithProxy("crystal");
        _this.crystal.x = Constants.ASSETS_WIDTH / 2;
        _this.crystal.y = 570;
        _this.glow = AssetsManager.g_instance.getCenteredImageWithProxy("crystal_glow");
        _this.glow.x = Constants.ASSETS_WIDTH / 2;
        _this.glow.y = 570;
        _this.addChild(_this.glow);
        _this.addChild(_this.crystal);
        _this.glow.alpha = 0.5;
        _this.crystal.scaleX = _this.crystal.scaleY = 0.85;
        _this.glow.scaleX = _this.glow.scaleY = 0.85;
        _this.glow.alpha = 0;
        createjs.Tween.get(_this.glow).wait(1700).to({ alpha: 0.7 }, 300, createjs.Ease.linear)
            .call(function () { SoundManager.g_instance.play(SoundManager.SOUND_SHAMAN); });
        _this.crystal.alpha = 0;
        createjs.Tween.get(_this.crystal).wait(400).to({ alpha: 1.0 }, 400, createjs.Ease.linear);
        return _this;
    }
    Shaman.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        this.crystal.y = 480 + Math.sin(this.liveTime * 1.2) * 12;
        this.glow.y = 480 + Math.sin(this.liveTime * 1.2) * 12;
        if (this.liveTime > 4.0 && !this.hidding) {
            this.hide();
        }
    };
    Shaman.prototype.hide = function () {
        var _this = this;
        this.hidding = true;
        createjs.Tween.get(this.crystal).to({ alpha: 0.0 }, 400, createjs.Ease.linear);
        createjs.Tween.get(this.glow).to({ alpha: 0.0 }, 400, createjs.Ease.linear);
        createjs.Tween.get(this).wait(4000).to({ alpha: 0.0 }, 400, createjs.Ease.linear).call(function () { return _this.kill(); });
    };
    return Shaman;
}(GameObject));
/// <reference path="references.ts" />
var TaskChipKiller = (function (_super) {
    __extends(TaskChipKiller, _super);
    function TaskChipKiller() {
        var _this = _super.call(this) || this;
        _this.killCount = 0;
        _this.timeToKill = 4.5;
        _this.chipsToKillCount = 13;
        if (PlayState.g_instance.getGoal() == PlayState.GOAL_DIRT) {
            _this.chipsToKillCount = 10; // ?? mb menshe
        }
        return _this;
    }
    TaskChipKiller.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        if (this.liveTime >= this.timeToKill) {
            PlayState.g_instance.killTaskChip();
            this.timeToKill = this.liveTime + 0.25;
            if (++this.killCount >= this.chipsToKillCount) {
                this.kill();
            }
        }
    };
    return TaskChipKiller;
}(GameObject));
/// <reference path="references.ts" />
var TaskEffect = (function (_super) {
    __extends(TaskEffect, _super);
    function TaskEffect(task, count, type, bonus_type, callback, tutor) {
        var _this = _super.call(this) || this;
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        _this.func = callback;
        if (!tutor) {
            var shader = new createjs.Shape();
            shader.graphics.beginFill("#000000");
            shader.graphics.drawRect(0, -diff - 60, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT + diff + 100);
            shader.graphics.endFill();
            _this.addChild(shader);
            shader.alpha = 0;
            createjs.Tween.get(shader).wait(1700).to({ alpha: 0.50 }, 500, createjs.Ease.linear).wait(1950).to({ alpha: 0.0 }, 400, createjs.Ease.linear);
        }
        switch (task) {
            case PlayState.GOAL_BONUS:
                _this.img = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_TASK_PANEL);
                _this.addChild(_this.img);
                var blabla_text = new BitmapLabel(StringManager.getInstance().getString(StringManager.REMOVE) + "  " + count.toString());
                blabla_text.alignH = DN_TEXT_ALIGN_HOR.CENTER;
                blabla_text.alignW = DN_TEXT_ALIGN_VERT.MIDDLE;
                blabla_text.y = -35;
                blabla_text.x = -70;
                _this.img.addChild(blabla_text);
                var goal_sprite = AssetsManager.g_instance.getCenteredImageWithProxy(PlayState.getImageByBonusType(bonus_type));
                goal_sprite.scaleX = goal_sprite.scaleY = 0.70;
                _this.img.addChild(goal_sprite);
                goal_sprite.x = 100;
                goal_sprite.y = -2;
                break;
            case PlayState.GOAL_DIRT:
                _this.img = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_TASK_PANEL);
                _this.addChild(_this.img);
                var blabla_text = new BitmapLabel(StringManager.getInstance().getString(StringManager.CLEAR), DN_TEXT_ALIGN_HOR.CENTER, 400);
                blabla_text.alignH = DN_TEXT_ALIGN_HOR.CENTER;
                blabla_text.alignW = DN_TEXT_ALIGN_VERT.MIDDLE;
                blabla_text.y = -35;
                blabla_text.x = 0;
                _this.img.addChild(blabla_text);
                break;
            case PlayState.GOAL_COUNT:
                _this.img = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_TASK_PANEL);
                _this.addChild(_this.img);
                var blabla_text = new BitmapLabel(StringManager.getInstance().getString(StringManager.REMOVE) + "  " + count.toString());
                blabla_text.alignH = DN_TEXT_ALIGN_HOR.CENTER;
                blabla_text.alignW = DN_TEXT_ALIGN_VERT.MIDDLE;
                blabla_text.y = -35;
                blabla_text.x = -67;
                _this.img.addChild(blabla_text);
                var goal_sprite = AssetsManager.g_instance.getCenteredImageWithProxy("cake_" + type);
                goal_sprite.scaleX = goal_sprite.scaleY = 0.70;
                _this.img.addChild(goal_sprite);
                goal_sprite.x = 110;
                goal_sprite.y = -2;
                break;
            case PlayState.GOAL_SCORE:
                _this.img = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_TASK_PANEL);
                _this.addChild(_this.img);
                if (PlayState.g_curLevel == 0) {
                    count = PlayState.g_instance.getGoalCount();
                }
                var blabla_text = new BitmapLabel(StringManager.getInstance().getString(StringManager.EARN) + "  " +
                    count.toString() + " " + StringManager.getInstance().getString(StringManager.POINTS));
                blabla_text.alignH = DN_TEXT_ALIGN_HOR.CENTER;
                blabla_text.alignW = DN_TEXT_ALIGN_VERT.MIDDLE;
                blabla_text.y = -35;
                blabla_text.x = 0;
                _this.img.addChild(blabla_text);
                break;
            default:
                break;
        }
        _this.img.y = -200;
        _this.img.x = Constants.ASSETS_WIDTH * 0.5;
        _this.img.alpha = 0;
        createjs.Tween.get(_this.img).
            wait(1300).
            to({ y: Constants.ASSETS_HEIGHT * 0.5, alpha: 1 }, 650, createjs.Ease.backOut).
            wait(2200).
            to({ y: Constants.ASSETS_HEIGHT + 200, alpha: 0 }, 400, createjs.Ease.backIn).
            call(function () { _this.func(); _this.kill(); });
        return _this;
    }
    return TaskEffect;
}(GameObject));
/// <reference path="references.ts" />
var TextBox = (function (_super) {
    __extends(TextBox, _super);
    function TextBox(text, max_width, max_height) {
        var _this = _super.call(this) || this;
        _this.textScale = 0.8;
        _this.minScale = 0.1;
        _this.maxTextWidth = max_width;
        _this.maxTextHeight = max_height;
        _this.font = "40px Mail Ray Stuff";
        _this.setText(text);
        return _this;
    }
    TextBox.prototype.setText = function (text) {
        this.removeAllChildren();
        if (true) {
            var debug_shape_1 = new createjs.Shape();
            debug_shape_1.graphics.beginFill("#ffffff");
            debug_shape_1.graphics.drawRoundRect(3, -25, this.maxTextWidth + 10, this.maxTextHeight + 10, 30);
            debug_shape_1.graphics.endFill();
            debug_shape_1.alpha = 0.7;
            debug_shape_1.x = -this.maxTextWidth / 2 - 8;
            this.addChild(debug_shape_1);
            var debug_shape = new createjs.Shape();
            debug_shape.graphics.beginFill("#ffffff");
            debug_shape.graphics.drawRoundRect(0, -20, this.maxTextWidth, this.maxTextHeight, 30);
            debug_shape.graphics.endFill();
            debug_shape.alpha = 1;
            debug_shape.x = -this.maxTextWidth / 2;
            this.addChild(debug_shape);
        }
        var max_h = 0;
        var label = new BitmapLabel(" ");
        var space_width = label.getBounds().width;
        var len = text.length;
        var word = "";
        var words = [];
        var max_word_width = 0;
        ////	    
        for (var i = 0; i < len + 1; i++) {
            if (text.charAt(i) == ' ' || i == len) {
                if (word.length != 0) {
                    var label = new BitmapLabel(word);
                    label.scaleX = label.scaleY = this.textScale;
                    words.push(label);
                    if (!label.getBounds()) {
                        console.log("text error");
                        return;
                    }
                    var word_width = label.getBounds().width;
                    if (word_width > max_word_width) {
                        max_word_width = word_width;
                    }
                }
                word = "";
            }
            else {
                word = word + text.charAt(i);
            }
        }
        var y = 0;
        var line = 0;
        var words_in_line = 0;
        var word_start_index = 0;
        for (var i = 0; i < words.length; i++) {
            line += (words[i].getBounds().width + space_width) * this.textScale;
            words_in_line++;
            var last_word_in_line = (i == words.length - 1);
            if (line > this.maxTextWidth || last_word_in_line) {
                if (words_in_line > 1 && line > this.maxTextWidth) {
                    line -= words[i].getBounds().width;
                    words_in_line--;
                    i--;
                }
                var cur_line = "";
                for (var w = word_start_index; w < word_start_index + words_in_line; w++) {
                    cur_line += words[w].getText();
                    cur_line += " ";
                }
                //cur_line.pop();	//	    
                var line_label = new BitmapLabel(cur_line);
                line_label.scaleX = line_label.scaleY = this.textScale;
                this.addChild(line_label);
                line_label.y = y;
                y += 40 * this.textScale;
                line = 0;
                word_start_index += words_in_line;
                words_in_line = 0;
                max_h = y;
            }
        }
        if ((max_h > this.maxTextHeight || max_word_width > this.maxTextWidth) && this.textScale > this.minScale) {
            this.textScale -= 0.05;
            this.setText(text);
        }
    };
    return TextBox;
}(GUIObject));
/// <reference path="references.ts" />
var TextBoxWebFont = (function (_super) {
    __extends(TextBoxWebFont, _super);
    function TextBoxWebFont(text, max_width, max_height) {
        var _this = _super.call(this) || this;
        _this.textScale = 0.8;
        _this.minScale = 0.1;
        _this.maxTextWidth = max_width;
        _this.maxTextHeight = max_height;
        _this.font = "40px Mail Ray Stuff";
        _this.setText(text);
        return _this;
    }
    TextBoxWebFont.prototype.setText = function (text) {
        this.removeAllChildren();
        var max_h = 0;
        var label = new BitmapLabel(" ");
        var space_width = label.getBounds().width;
        var len = text.length;
        var word = "";
        var words = [];
        var max_word_width = 0;
        ////	    
        for (var i = 0; i < len + 1; i++) {
            if (text.charAt(i) == ' ' || i == len) {
                if (word.length != 0) {
                    var label = new BitmapLabel(word);
                    label.scaleX = label.scaleY = this.textScale;
                    words.push(label);
                    if (!label.getBounds()) {
                        console.log("text error");
                        return;
                    }
                    var word_width = label.getBounds().width;
                    if (word_width > max_word_width) {
                        max_word_width = word_width;
                    }
                }
                word = "";
            }
            else {
                word = word + text.charAt(i);
            }
        }
        var y = 0;
        var line = 0;
        var words_in_line = 0;
        var word_start_index = 0;
        for (var i = 0; i < words.length; i++) {
            line += (words[i].getBounds().width + space_width) * this.textScale;
            words_in_line++;
            var last_word_in_line = (i == words.length - 1);
            if (line > this.maxTextWidth || last_word_in_line) {
                if (words_in_line > 1 && line > this.maxTextWidth) {
                    line -= words[i].getBounds().width;
                    words_in_line--;
                    i--;
                }
                var cur_line = "";
                for (var w = word_start_index; w < word_start_index + words_in_line; w++) {
                    cur_line += words[w].getText();
                    cur_line += " ";
                }
                //cur_line.pop();	//	    
                var line_label = new BitmapLabel(cur_line);
                line_label.scaleX = line_label.scaleY = this.textScale;
                this.addChild(line_label);
                line_label.y = y;
                y += 40 * this.textScale;
                line = 0;
                word_start_index += words_in_line;
                words_in_line = 0;
                max_h = y;
            }
        }
        if ((max_h > this.maxTextHeight || max_word_width > this.maxTextWidth) && this.textScale > this.minScale) {
            this.textScale -= 0.05;
            this.setText(text);
        }
    };
    return TextBoxWebFont;
}(GUIObject));
/// <reference path="references.ts" />
var UnlockAchievmentState = (function (_super) {
    __extends(UnlockAchievmentState, _super);
    function UnlockAchievmentState(callback) {
        var _this = _super.call(this) || this;
        _this.shader = new createjs.Shape();
        _this.startAnim = false;
        _this.endAnim = false;
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        _this.func = callback;
        _this.shader = new createjs.Shape();
        _this.shader.graphics.beginFill("#000000");
        _this.shader.graphics.drawRect(0, -diff, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT + diff);
        _this.shader.graphics.endFill();
        _this.addChild(_this.shader);
        _this.shader.alpha = 0;
        createjs.Tween.get(_this.shader, { loop: false }).wait(300).to({ alpha: 0.4 }, 800, createjs.Ease.linear);
        _this.shining = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_SHINING);
        _this.addChild(_this.shining);
        _this.shining.x = Constants.ASSETS_WIDTH / 2;
        _this.shining.y = Constants.ASSETS_HEIGHT / 2 - diff;
        _this.shining.scaleX = _this.shining.scaleY = 0;
        createjs.Tween.get(_this.shining, { loop: false }).to({ scaleX: 4.5, scaleY: 4.5 }, 800, createjs.Ease.linear)
            .call(function () { _this.startAnim = true; _this.liveTime = 0; });
        _this.shining.alpha = 0;
        createjs.Tween.get(_this.shining, { loop: false }).to({ alpha: 0.8 }, 400, createjs.Ease.linear);
        createjs.Tween.get(_this.shining, { loop: false }).to({ rotation: 100 }, 800, createjs.Ease.linear);
        _this.achievement = AssetsManager.g_instance.getCenteredImageWithProxy("achievement_" + GameData.getInstance().getAchievementsNum() + "_map");
        _this.achievement.scaleX = _this.achievement.scaleY = 0;
        _this.achievement.rotation = -120;
        _this.achievement.x = Constants.ASSETS_WIDTH / 2;
        _this.achievement.y = Constants.ASSETS_HEIGHT / 2 - diff - 20;
        _this.addChild(_this.achievement);
        createjs.Tween.get(_this.achievement).wait(300).to({ rotation: 0, scaleY: 1.4, scaleX: 1.4 }, 500, createjs.Ease.circOut);
        _this.panel = AssetsManager.g_instance.getCenteredImageWithProxy("pause_panel");
        _this.addChild(_this.panel);
        _this.panel.x = _this.achievement.x;
        _this.panel.y = _this.achievement.y + 200;
        _this.panel.alpha = 0;
        createjs.Tween.get(_this.panel).wait(400).to({ alpha: 1 }, 300, createjs.Ease.linear);
        _this.text = new BitmapLabel(StringManager.getInstance().getString(StringManager.NEW_TREASURE), DN_TEXT_ALIGN_HOR.CENTER, 500);
        _this.panel.addChild(_this.text);
        _this.text.alpha = 0;
        _this.text.y = -25;
        _this.text.scaleX = _this.text.scaleY = 0.7;
        createjs.Tween.get(_this.text).wait(400).to({ alpha: 1 }, 300, createjs.Ease.linear);
        GameData.getInstance().onAchievementShow();
        return _this;
    }
    UnlockAchievmentState.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        if (this.startAnim) {
            this.shining.rotation += 5 * dt;
        }
        if (this.endAnim) {
            this.endAnim = false;
            this.hideAll();
        }
    };
    UnlockAchievmentState.prototype.hideAll = function () {
        var _this = this;
        createjs.Tween.get(this.achievement).to({ alpha: 0 }, 700, createjs.Ease.circOut)
            .call(function () { StateManager.g_instance.popState(); _this.func(); });
        createjs.Tween.get(this.shining).to({ alpha: 0 }, 300, createjs.Ease.circOut);
        createjs.Tween.get(this.shader).to({ alpha: 0 }, 300, createjs.Ease.circOut);
        createjs.Tween.get(this.text).to({ alpha: 0 }, 300, createjs.Ease.circOut);
        createjs.Tween.get(this.panel).to({ alpha: 0 }, 300, createjs.Ease.circOut);
    };
    UnlockAchievmentState.prototype.onMouseDown = function (x, y) {
        _super.prototype.onMouseDown.call(this, x, y);
        if (this.liveTime > 1.5 && this.startAnim) {
            this.endAnim = true;
            this.startAnim = false;
        }
    };
    return UnlockAchievmentState;
}(GameState));
/// <reference path="references.ts" />
var VerticalLightEffect = (function (_super) {
    __extends(VerticalLightEffect, _super);
    function VerticalLightEffect() {
        var _this = _super.call(this) || this;
        _this.vertFrames = new Array();
        _this.vertFrame = -1;
        return _this;
        //this.frameTime = frame_time;
        //for (var i: number = 0; i < count; i++)
        //{
        //    this.frames.push(AssetsManager.g_instance.getCenteredImageWithProxy(name + i));
        //}
        //this.update(100);
    }
    VerticalLightEffect.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        //if (this.liveTime > this.frameTime)
        //{
        //    this.liveTime = 0;
        //    this.frame++;
        //    if (this.frame >= this.frames.length)
        //    {
        //        this.frame = this.frames.length - 1;
        //        this.kill();
        //    }
        //    this.removeAllChildren();
        //    var pic: createjs.DisplayObject = this.frames[this.frame];
        //    this.addChild(pic);
        //}
    };
    return VerticalLightEffect;
}(GameObject));
/// <reference path="MainMenuState.ts" />
var WinState = (function (_super) {
    __extends(WinState, _super);
    function WinState(level, score) {
        var _this = _super.call(this) || this;
        _this.panel = new createjs.Container();
        _this.hiddingNow = false;
        _this.isAchievment = false;
        _this.lastLevel = false;
        _this.startAnim = false;
        _this.captionAmplitude = 1;
        GameData.getInstance().onWinLevel(level, score);
        var diff = (Constants.SCREEN_HEIGHT - Constants.ASSETS_HEIGHT) / 2;
        if (GameData.getInstance().levelsAvailable() - 1 == (level + 1) && GameData.getInstance().isLevelGotAchievement(level + 1)) {
            GameData.getInstance().addAchievment();
            _this.isAchievment = true;
        }
        _this.lastLevel = GameData.getInstance().getTotalLevels() == (level + 1);
        //  shading
        _this.shader = new createjs.Shape();
        _this.shader.graphics.beginFill("#000000");
        _this.shader.graphics.drawRect(0, -diff, Constants.ASSETS_WIDTH, Constants.SCREEN_HEIGHT + diff);
        _this.shader.graphics.endFill();
        _this.addChild(_this.shader);
        _this.shader.alpha = 0;
        _this.shaderTween = createjs.Tween.get(_this.shader, { loop: false }).wait(400).to({ alpha: 0.4 }, 800, createjs.Ease.linear);
        _this.addChild(_this.panel);
        _this.panel.x = Constants.ASSETS_WIDTH / 2;
        _this.panel.y = Constants.SCREEN_HEIGHT / 2 - diff;
        var panel = AssetsManager.g_instance.getCenteredImage(Constants.IMAGE_MESSAGE_WINDOW);
        _this.panel.addChild(panel);
        _this.winCaption = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_WIN_CAPTION);
        _this.panel.addChild(_this.winCaption);
        _this.winCaption.y = -270;
        _this.winCaption.scaleX = _this.winCaption.scaleY = 0;
        _this.winCaption.rotation = -120;
        createjs.Tween.get(_this.winCaption).wait(300).to({ rotation: 0, scaleY: 1, scaleX: 1 }, 500, createjs.Ease.circOut).wait(600)
            .call(function () { _this.startAnim = true; _this.liveTime = 0; });
        _this.eyesFlash = AssetsManager.g_instance.getCenteredImageWithProxy(Constants.IMAGE_WIN_CAPTION_EYES);
        _this.winCaption.addChild(_this.eyesFlash);
        _this.eyesFlash.alpha = 0;
        createjs.Tween.get(_this.eyesFlash).wait(700).to({ alpha: 1.0 }, 700, createjs.Ease.circOut);
        //----------------------------------
        var caption_x = -180;
        var digits_x = +180;
        _this.panel.alpha = 0.0;
        createjs.Tween.get(_this.panel, { loop: false }).to({ alpha: 1 }, 200, createjs.Ease.linear);
        _this.panel.scaleX = 0.7;
        _this.panel.scaleY = 0.7;
        createjs.Tween.get(_this.panel, { loop: false }).to({ scaleX: 1, scaleY: 1 }, 400, createjs.Ease.backOut);
        var panel_1 = AssetsManager.g_instance.getCenteredImageWithProxy("pause_panel");
        _this.panel.addChild(panel_1);
        panel_1.x = 0;
        panel_1.y = -50;
        var cup = AssetsManager.g_instance.getImage("score_bonus");
        panel_1.addChild(cup);
        cup.x = -165;
        cup.y = -30;
        cup.scaleX = cup.scaleY = 0.7;
        var score_string = new DNTextField(Utils.GetScoreString(score), "font_", 0);
        panel_1.addChild(score_string);
        score_string.x = -45;
        score_string.y = -17;
        score_string.scaleX = score_string.scaleY = 1.15;
        if (_this.isAchievment == false && _this.lastLevel == false) {
            var button_restart = new DNButton(Constants.IMAGE_BUTTON_RESTART, function () { return _this.onRestartTouch(); });
            _this.panel.addChild(button_restart);
            _this.addGuiObject(button_restart);
            button_restart.x = 160;
            button_restart.y = 150;
            var button_exit = new DNButton(Constants.IMAGE_BUTTON_EXIT, function () { return _this.onExitTouch(); });
            _this.panel.addChild(button_exit);
            _this.addGuiObject(button_exit);
            button_exit.x = -160;
            button_exit.y = 150;
        }
        var button_next = new DNButton(Constants.IMAGE_BUTTON_PLAY, function () { return _this.onNextTouch(); });
        _this.panel.addChild(button_next);
        _this.addGuiObject(button_next);
        button_next.scaleX = button_next.scaleY = 0.8;
        button_next.x = 0;
        button_next.y = 125;
        try {
            analytics.level(PlayState.g_curLevel + 1);
            analytics.score(GameData.getInstance().getTotalScore());
            community.submitScore({
                score: GameData.getInstance().getTotalScore(),
                callback: function () {
                    if (enableAds == true) {
                        if (StateManager.g_instance.adsCD <= 0) {
                            StateManager.g_instance.restartAdsCD();
                            adSense.showAdvertising();
                        }
                    }
                }
            });
        }
        catch (e) {
        }
        return _this;
    }
    WinState.prototype.hide = function () {
        if (!this.hiddingNow) {
            createjs.Tween.get(this.shader, { loop: false }).to({ alpha: 0.0 }, 400, createjs.Ease.linear).call(function () { StateManager.g_instance.popState(); });
            createjs.Tween.get(this.panel, { loop: false }).to({ y: -300 }, 300, createjs.Ease.backIn);
            createjs.Tween.get(this.panel, { loop: false }).to({ alpha: 0 }, 300, createjs.Ease.linear);
            this.hiddingNow = true;
        }
    };
    WinState.prototype.update = function (dt) {
        _super.prototype.update.call(this, dt);
        if (this.startAnim) {
            if (this.captionAmplitude <= 4) {
                this.captionAmplitude += dt * 5;
            }
            this.winCaption.rotation = Math.sin(this.liveTime * 2) * this.captionAmplitude;
            this.eyesFlash.alpha = 1.0 + Math.sin(this.liveTime * 4) * 0.1;
        }
    };
    WinState.prototype.onRestartTouch = function () {
        if (enableAds == true) {
            try {
                if (StateManager.g_instance.adsCD <= 0) {
                    StateManager.g_instance.restartAdsCD();
                    adSense.showAdvertising();
                }
            }
            catch (e) {
            }
        }
        StateManager.g_instance.pushState(new ShadeInState(new PlayState(PlayState.g_curLevel, false)));
    };
    WinState.prototype.onExitTouch = function () {
        if (enableAds == true) {
            try {
                if (StateManager.g_instance.adsCD <= 0) {
                    StateManager.g_instance.restartAdsCD();
                    adSense.showAdvertising();
                }
            }
            catch (e) {
            }
        }
        StateManager.g_instance.pushState(new GradientInState(new SelectLevelState()));
    };
    WinState.prototype.onNextTouch = function () {
        //
        if (PlayState.g_curLevel < GameData.getInstance().levelsAvailable() && !this.isAchievment && !this.lastLevel) {
            StateManager.g_instance.pushState(new GradientInState(new PlayState(PlayState.g_curLevel + 1, true)));
            //StateManager.g_instance.pushState(new GradientInState(new SelectLevelState()));
        }
        else if (this.isAchievment || this.lastLevel) {
            StateManager.g_instance.pushState(new GradientInState(new SelectLevelState()));
            //StateManager.g_instance.pushState(new ShadeInState(new SelectLevelState()));
        }
    };
    return WinState;
}(GameState));